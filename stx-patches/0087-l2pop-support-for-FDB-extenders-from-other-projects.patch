From 4ae5a5878f7c2dff0ae92590c54f037845ea2436 Mon Sep 17 00:00:00 2001
From: Allain Legacy <allain.legacy@windriver.com>
Date: Thu, 31 Aug 2017 13:18:48 -0500
Subject: [PATCH 087/155] l2pop: support for FDB extenders from other projects

Adding a extension registration mechanism so that other subprojects can
extend the information included in a full FDB messages before it is sent
to the agent.  At this time it will be used by BGPVPN to add information
that was learned from peer BGP routers.
---
 neutron/plugins/ml2/drivers/l2pop/mech_driver.py   | 44 ++++++++++++++++++----
 .../drivers/l2pop/rpc_manager/l2population_rpc.py  |  9 ++++-
 2 files changed, 43 insertions(+), 10 deletions(-)

diff --git a/neutron/plugins/ml2/drivers/l2pop/mech_driver.py b/neutron/plugins/ml2/drivers/l2pop/mech_driver.py
index cb51106..251ef41 100644
--- a/neutron/plugins/ml2/drivers/l2pop/mech_driver.py
+++ b/neutron/plugins/ml2/drivers/l2pop/mech_driver.py
@@ -13,6 +13,9 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import six
+
+from neutron_lib.api.definitions import provider_net as provider
 from neutron_lib import constants as const
 from neutron_lib import context as n_context
 from neutron_lib import exceptions
@@ -26,7 +29,6 @@ from neutron._i18n import _
 from neutron.conf.plugins.ml2.drivers import l2pop as config
 from neutron.db import api as db_api
 from neutron.db import l3_hamode_db
-from neutron.extensions import providernet as provider
 from neutron.plugins.ml2.drivers.l2pop import db as l2pop_db
 from neutron.plugins.ml2.drivers.l2pop import rpc as l2pop_rpc
 from neutron import service
@@ -36,6 +38,25 @@ LOG = logging.getLogger(__name__)
 config.register_l2_population_opts()
 
 
+l2pop_fdb_extend_funcs = {}
+
+
+def register_fdb_extend_func(name, func):
+    l2pop_fdb_extend_funcs[name] = func
+
+
+def run_fdb_extend_funcs(context, network_id, fdb_entries, source=None):
+    for name, func in six.iteritems(l2pop_fdb_extend_funcs):
+        if source and name == source:
+            # Avoid data loops and do not provide data from a source back to
+            # itself when it requests a full data set.  (e.g., the bgpvpn
+            # agent should not get its own data when it queries the fdb for
+            # a network).
+            continue
+        fdb_entries = func(context, network_id, fdb_entries)
+    return fdb_entries
+
+
 class L2populationMechanismDriver(api.MechanismDriver):
 
     def __init__(self):
@@ -230,7 +251,9 @@ class L2populationMechanismDriver(api.MechanismDriver):
 
         return True
 
-    def _create_agent_fdb(self, session, agent, segment, network_id):
+    def _create_agent_fdb(self, context, agent, segment, network_id,
+                          source=None):
+        session = context.session
         agent_fdb_entries = {network_id:
                              {'segment_id': segment['segmentation_id'],
                               'network_type': segment['network_type'],
@@ -256,7 +279,9 @@ class L2populationMechanismDriver(api.MechanismDriver):
                 if ip == agent_ip:
                     fdbs.extend(self._get_port_fdb_entries(binding.port))
 
-        return agent_fdb_entries
+        return run_fdb_extend_funcs(context, network_id,
+                                    agent_fdb_entries,
+                                    source=source)
 
     def _get_tunnels(self, tunnel_network_ports, exclude_host,
                      physical_network=None):
@@ -323,7 +348,7 @@ class L2populationMechanismDriver(api.MechanismDriver):
                                        cfg.CONF.l2pop.agent_boot_time):
             # First port activated on current agent in this network,
             # we have to provide it with the whole list of fdb entries
-            agent_fdb_entries = self._create_agent_fdb(session,
+            agent_fdb_entries = self._create_agent_fdb(context.context,
                                                        agent,
                                                        segment,
                                                        network_id)
@@ -393,19 +418,22 @@ class L2populationMechanismDriver(api.MechanismDriver):
             template[network_id]['physical_network'] = physical_network
         return template
 
-    def _get_fdb_entries(self, context, plugin, network_id, host):
+    def _get_fdb_entries(self, context, plugin, network_id, host,
+                         source=None):
         network = plugin.get_network(context, network_id)
         segment = {
             'network_type': network[provider.NETWORK_TYPE],
             'physical_network': network[provider.PHYSICAL_NETWORK],
             'segmentation_id': network[provider.SEGMENTATION_ID]}
         return self._create_agent_fdb(
-            context.session, host, segment, network_id)
+            context, host, segment, network_id, source=source)
 
-    def get_fdb_entries(self, context, network_ids, host=None):
+    def get_fdb_entries(self, context, network_ids, host=None,
+                        source=None):
         fdb_entries = {}
         plugin = directory.get_plugin()
         for network_id in network_ids:
-            entries = self._get_fdb_entries(context, plugin, network_id, host)
+            entries = self._get_fdb_entries(
+                context, plugin, network_id, host, source=source)
             fdb_entries.update(entries)
         return fdb_entries
diff --git a/neutron/plugins/ml2/drivers/l2pop/rpc_manager/l2population_rpc.py b/neutron/plugins/ml2/drivers/l2pop/rpc_manager/l2population_rpc.py
index ad223ae..d358f85 100644
--- a/neutron/plugins/ml2/drivers/l2pop/rpc_manager/l2population_rpc.py
+++ b/neutron/plugins/ml2/drivers/l2pop/rpc_manager/l2population_rpc.py
@@ -41,18 +41,23 @@ class L2populationRpcQueryMixin(object):
         target = oslo_messaging.Target(topic=topic, version='1.0')
         self.client = n_rpc.get_client(target)
 
-    def get_fdb_entries(self, context, network_ids, host=None):
+    def get_fdb_entries(self, context, network_ids, host=None,
+                        source=None):
         """
         Retrieves the FDB entries required to populate the FDB on a given
         host.
 
+        If 'source' is specified as a requestor then no records from that
+        source are included in the results.
+
         If host is not supplied then the full set of FDB entries for the
         network is returned.
         """
         cctxt = self.client.prepare()
         results = cctxt.call(context, 'get_fdb_entries',
                              network_ids=network_ids,
-                             host=host)
+                             host=host,
+                             source=source)
         return L2populationRpcCallBackMixin._unmarshall_fdb_entries(results)
 
 
-- 
2.7.4

