From cb084bf2c44feeace8df6a0103448cde171a9873 Mon Sep 17 00:00:00 2001
From: Matt Peters <matt.peters@windriver.com>
Date: Thu, 19 May 2016 13:42:53 -0400
Subject: [PATCH 015/155] avs: l2 and l3 agents and drivers for avs vswitch

This commit introduces two new neutron agents that provide support for
the WRS AVS vswitch.  If AVS is to be used then these agents must be
used instead of the stock neutron-l2-agent and neutron-l3-agent that are
packaged in neutron.

Conflicts:
	setup.cfg

CGTS-6612: DVR: floatingip_agent_gateway port not deleted

Currently, the floating ip agent gateway port is only deleted when the
last gateway port of the external network is deleted.

This means that even when a floating ip router on a node is deleted
(because no instance on that node needs it), the agent gateway port
can remain indefinitely, holding onto whatever resources were allocated
to it.

The upstream community developed a fix for this in commit
639f189, with the local dvr agent deleting the namespace and using an
RPC call to delete the agent gateway port.  This was later partly removed
when races were found in rapidly creating/deleting the namespace.

Since our solution does not use floating ip namespaces, and we delete
the AVS fip router when it is no longer needed, I believe it's possible for
us to delete the agent gateway port at the same time.

The second part of this fix serializes the create_fip_agent_gw_port_if_not_exists
function:

When stress testing the agent port delete part of this fix, a race was found
in the create_fip_agent_gw_port_if_no_exists function. This could be seen with 4VMs
split evenly between two compute hosts constantly adding and removing floating
IPs.  When both VMs on a host removed their floating IP at the same time, the
agent gateway port was deleted. They both immediately tried to add the floating
IP back, causing create_fip_agent_gw_port_if_not_exists to be called.

In create_fip_agent_gw_port_if_not_exists, the db is checked for whether an agent
gateway port already exists for a host.  If it doesn't, one is created.

It's possible that two concurrent calls to the above function
can determine there is no agent gateway port (before any one of them is
actually created by the ml2 driver).  In this case, the last gateway
port created is the one that will be used by the AVS agent.

When the fip router is deleted, only one of the two agent gateway ports will
in turn be removed by the delete_floatingip_agent_gateway_port function
of the l3_dvr_db code (it expects only one to ever exist).

CGTS-6989: avs: process ports and ifaces in create order

To avoid issues related to making nova wait a long time for a vif-plugged event
process ports/ifaces in the order in which they were created.  What was
observed is that it is possible for a large number of ports to get created
before the agent notices them.  When it wakes up and starts processing them it
is possible that the first port that was created since the last scan is the
last port processed.  This increases the time required to get a vif-plugged
event to nova.

Normally this shouldn't be much of a problem since the agent hooks up ports
rather quickly but when the DB is bogged down it can take a long time (>1min)
therefore it is advantageous to do them in order to minimimize setup time on a
per instance basis.

dvr: fixing static analysis warnings from pycharm

CGTS-7273: avr: filter arp entry events for existing routers only

The ARP update/delete events from the server are broadcast to all agents.  That
causes all nodes to go back up to the server and get the router sync data for
the related router.  Since only a small portion of agents will actually be
associated to that router it turns out to be a huge waste of resources to allow
the agents to do this.

Instead, the agent can filter the event based on its router list and ignore
unrelated events.

CGTS-7400: Upgrade: R2->R3 - VLAN interface MTU changes

The MTU of the interface within the vswitch is set incorrectly to the MTU of
the lower interface. The MTU should be set to the MTU of the provider network.

avs: fixing uninitialized variable reference in interface driver

pycharm has flagged that the "ip" variable is used unitialized in the
else clause.  Not sure why we have never seen this as it should be a
valid (albeit rare) code path.

CGTS-7450: avs: allow unplug to pass if port is non present

There are code paths in the dhcp agent where a port is unplugged
multiple times.  One such case is when a vlan subnet is deleted.  In
that case the port is first updated with an empty fixed_ips attribute.
That causes the subnet to get deleted by the agent and the avs port to
be deleted.  Then the subnet delete RPC is received and the agent again
tries to remove the avs port but it no longer exist, and exception is
caught, and the agent goes down a complicated recovery path for no
reason.

CGTS-7546: avs: fixed exception while testing flat providernet

Unfortunately, the server code does not set the 'segmentation_id'
attribute in the data that is passed to the agent when starting a
providernet test.  This should be the case given that the
segmentation_id is always set in order instances of RPC message going to
the agent regardless of the network_type.

Since the current approach work in the past and is only broken because
of an SDN change that overlooked this testcase it is being put back to
the way that it used to operate.

tests: fix avs interface driver tests for mtu

The MTU attribute was not handled properly and caused interface MTU values of 0
during functional tests.

US79271: AVS support for vhost - AVS changes

In order to prepare for rebasing, these changes are split from the
rest of the changes for this feature.

CGTS-7625: Default Gateway missing from AVS Router when IPv4/IPv6 subnets used

The current behavior only allows one default gateway to be configured when
multiple subnets are present on the external network.  This restriction is
being relaxed to allow a separate default route to be installed for each
gateway of each address family (IPv4 and IPv6).  Multiple gateways within
the same address family are not supported and will only use the first
gateway of a subnet within that family.

CGTS-7240: avs: cache providernet details

When configuring a new port or interface the agent invokes an RPC on the server
to query the providernet details.  This is done repeatedly as the agent
discovers a port for the first time and then later handles update events on
that same port.  To reduce the number of providernet RPC calls we are now
caching the data in the agent and purging it when the related network is
deleted.

The providernet details will never change over the lifetime of the network so
this should not be leading to any stale data.

CGTS-7240: dvr: eliminate RPC calls by using local state info

The DVR sub-agent was invoking server RPC methods to gather interface
and subnet information for the purpose of configuring DVR state in AVS.
Since the agent already has port details cached that also includes
full subnet information there is no need to go back to the server to get
similar information via different RPC calls.

By relying on local state we should be able to significantly speed up
agent setup time when new interfaces/ports appear.

CGTS-7689: dvr: fixup for RPC optimization

This is a fixup for commit 25ca6107e where the list of subnets was not
pruned to only those having an IP address on a given subnet.  The result
was that all interfaces appeared in all DVR subnets and so as the agent
hooked them up to their interfaces it went through and overwrote
previous subnet-to-interface mappings.

For regular interfaces this is not much of an issue for AVS but for
router interfaces because they are charged with adding/deleting DVR
subnets in AVS the result of overwriting their mapping is that the AVS
DVR subnet was orphaned and left pointing to stale data.

avs: agent runtime caching of new networks

Until we move all RPC event handling to be dispatched to the main loop we need
to ensure that any new networks are cached immediately.  This ensures that RPC
messages that are received as a result of some port being created and connected
to its network can be handled properly by the RPC event (i.e., l2pop).

Conflicts:
	neutron/opts.py
	neutron/services/segments/db.py
	setup.cfg
---
 etc/oslo-config-generator/avs_agent.ini            |    8 +
 neutron/agent/vswitch/__init__.py                  |    0
 neutron/agent/vswitch/api.py                       |  698 +++++++
 neutron/agent/vswitch/constants.py                 |  100 +
 neutron/agent/vswitch/exceptions.py                |  411 +++++
 neutron/agent/vswitch/interface.py                 |  119 ++
 neutron/agent/vswitch/manager.py                   | 1314 +++++++++++++
 neutron/agent/vswitch/vif_api.py                   |   99 +
 neutron/db/l3_dvr_db.py                            |    2 +
 neutron/extensions/wrs_binding.py                  |    5 +
 neutron/opts.py                                    |   21 +
 neutron/plugins/wrs/agent/__init__.py              |    0
 neutron/plugins/wrs/agent/avr/__init__.py          |    0
 neutron/plugins/wrs/agent/avr/agent.py             | 1389 ++++++++++++++
 neutron/plugins/wrs/agent/avs/__init__.py          |    0
 neutron/plugins/wrs/agent/avs/agent.py             | 1934 ++++++++++++++++++++
 neutron/plugins/wrs/agent/avs/dvr.py               |  300 +++
 neutron/plugins/wrs/drivers/mech_vswitch.py        |  145 ++
 neutron/services/segments/db.py                    |    2 +
 neutron/tests/functional/vswitch/__init__.py       |    0
 .../tests/functional/vswitch/test_vswitch_agent.py |  243 +++
 .../tests/functional/vswitch/test_vswitch_api.py   |  448 +++++
 .../functional/vswitch/test_vswitch_interface.py   |  113 ++
 .../unit/plugins/wrs/drivers/test_mech_vswitch.py  |   81 +
 setup.cfg                                          |    6 +
 25 files changed, 7438 insertions(+)
 create mode 100644 etc/oslo-config-generator/avs_agent.ini
 create mode 100644 neutron/agent/vswitch/__init__.py
 create mode 100644 neutron/agent/vswitch/api.py
 create mode 100644 neutron/agent/vswitch/constants.py
 create mode 100644 neutron/agent/vswitch/exceptions.py
 create mode 100644 neutron/agent/vswitch/interface.py
 create mode 100644 neutron/agent/vswitch/manager.py
 create mode 100644 neutron/agent/vswitch/vif_api.py
 create mode 100644 neutron/plugins/wrs/agent/__init__.py
 create mode 100644 neutron/plugins/wrs/agent/avr/__init__.py
 create mode 100644 neutron/plugins/wrs/agent/avr/agent.py
 create mode 100644 neutron/plugins/wrs/agent/avs/__init__.py
 create mode 100644 neutron/plugins/wrs/agent/avs/agent.py
 create mode 100644 neutron/plugins/wrs/agent/avs/dvr.py
 create mode 100644 neutron/plugins/wrs/drivers/mech_vswitch.py
 create mode 100644 neutron/tests/functional/vswitch/__init__.py
 create mode 100644 neutron/tests/functional/vswitch/test_vswitch_agent.py
 create mode 100644 neutron/tests/functional/vswitch/test_vswitch_api.py
 create mode 100644 neutron/tests/functional/vswitch/test_vswitch_interface.py
 create mode 100644 neutron/tests/unit/plugins/wrs/drivers/test_mech_vswitch.py

diff --git a/etc/oslo-config-generator/avs_agent.ini b/etc/oslo-config-generator/avs_agent.ini
new file mode 100644
index 0000000..917292a
--- /dev/null
+++ b/etc/oslo-config-generator/avs_agent.ini
@@ -0,0 +1,8 @@
+[DEFAULT]
+# TODO(alegacy): rename to avs_agent.ini.sample
+output_file = etc/vswitch_agent.ini.sample
+wrap_width = 79
+
+namespace = neutron.base.agent
+namespace = neutron.avs.agent
+namespace = oslo.log
diff --git a/neutron/agent/vswitch/__init__.py b/neutron/agent/vswitch/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/agent/vswitch/api.py b/neutron/agent/vswitch/api.py
new file mode 100644
index 0000000..f20989d
--- /dev/null
+++ b/neutron/agent/vswitch/api.py
@@ -0,0 +1,698 @@
+# Copyright 2012 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+
+#
+# Copyright (c) 2013-2016 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+import threading
+
+from neutron.agent.vswitch import constants
+from neutron.agent.vswitch import exceptions
+from neutron.agent.vswitch import vif_api
+
+from vswitchclient import client
+from vswitchclient import exc
+
+
+class VSwitchManagementAPI(object):
+    """
+    Implements a wrapper to the vswitch client API
+    """
+
+    def __init__(self):
+        self.client = client.Client(constants.VSWITCH_CLIENT_VERSION,
+                                    constants.VSWITCH_CLIENT_ENDPOINT)
+        self._lock = threading.Lock()
+        self.vif_notifier = vif_api.VifAgentNotifier()
+
+    def _do_request(self, callable):
+        """
+        Thread safe wrapper for executing client requests.
+        """
+        with self._lock:
+            return callable()
+
+    def vif_created(self, port_uuid):
+        """
+        Send a notification to the L2 agent to signal that a new interface has
+        been added.
+        """
+        self._do_request(
+            lambda: self.vif_notifier.vif_created(port_uuid))
+
+    def vif_deleted(self, port_uuid):
+        """
+        Send a notification to the L2 agent to signal that a new interface has
+        been removed.
+        """
+        self._do_request(
+            lambda: self.vif_notifier.vif_deleted(port_uuid))
+
+    def _execute_engine_request(self, callable, engine=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchEngineNotFoundError(str(e), engine)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchEngineError(str(e), engine)
+
+    def _execute_port_request(self, callable, port=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchPortNotFoundError(str(e), port)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchPortError(str(e), port)
+
+    def _execute_interface_request(self, callable, interface=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchInterfaceNotFoundError(str(e), interface)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchInterfaceError(str(e), interface)
+
+    def _execute_network_request(self, callable, network=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchNetworkNotFoundError(str(e), network)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchNetworkError(str(e), network)
+
+    def _execute_filter_request(self, callable, rule=None, port=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchFilterNotFoundError(str(e), rule, port)
+        except exc.HTTPForbidden as e:
+            raise exceptions.VSwitchFilterForbiddenError(str(e), rule, port)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchFilterError(str(e), rule, port)
+
+    def _execute_neighbour_request(self, callable, neighbour=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchNeighbourNotFoundError(str(e), neighbour)
+        except exc.HTTPForbidden as e:
+            raise exceptions.VSwitchNeighbourForbiddenError(str(e), neighbour)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchNeighbourError(str(e), neighbour)
+
+    def _execute_address_request(self, callable, address=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchAddressNotFoundError(str(e), address)
+        except exc.HTTPForbidden as e:
+            raise exceptions.VSwitchAddressForbiddenError(str(e), address)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchAddressError(str(e), address)
+
+    def _execute_route_request(self, callable, route=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchRouteNotFoundError(str(e), route)
+        except exc.HTTPForbidden as e:
+            raise exceptions.VSwitchRouteForbiddenError(str(e), route)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchRouteError(str(e), route)
+
+    def _execute_router_request(self, callable, router=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchRouterNotFoundError(str(e), router)
+        except exc.HTTPForbidden as e:
+            raise exceptions.VSwitchRouterForbiddenError(str(e), router)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchRouterError(str(e), router)
+
+    def _execute_dvr_request(self, callable, router=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except Exception as e:
+            raise exceptions.VSwitchDvrError(str(e))
+
+    def _execute_snat_request(self, callable, snat=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+        except exc.HTTPNotFound as e:
+            raise exceptions.VSwitchSnatNotFoundError(str(e), snat)
+        except exc.HTTPConflict as e:
+            raise exceptions.VSwitchSnatPortBusyError(str(e), snat)
+        except exc.HTTPException as e:
+            raise exceptions.VSwitchSnatError(str(e), snat)
+
+    def _execute_ping_request(self, callable, body=None):
+        try:
+            return self._do_request(callable)
+        except exc.CommunicationError as e:
+            raise exceptions.VSwitchCommunicationError(str(e))
+
+    def get_engine_list_stats(self):
+        """
+        Sends a request to the vswitch requesting the current list of engine
+        object instances along with their statistics
+        """
+        return self._execute_engine_request(self.client.engine.list_stats)
+
+    def lock_port(self, port):
+        """
+        Sends a request to the vswitch requesting the lock of a port object
+        instance.
+        """
+        self._execute_port_request(
+            lambda: self.client.port.lock(port['uuid']), port)
+
+    def unlock_port(self, port):
+        """
+        Sends a request to the vswitch requesting the unlock of a port
+        object instance.
+        """
+        self._execute_port_request(
+            lambda: self.client.port.unlock(port['uuid']), port)
+
+    def attach_port(self, port):
+        """
+        Sends a request to the vswitch requesting the attachment of a port
+        object instance to a network object instance.
+        """
+        self._execute_port_request(
+            lambda: self.client.port.attach(
+                port['uuid'], port['network-uuid']), port)
+
+    def detach_port(self, port):
+        """
+        Sends a request to the vswitch requesting the attachment of a port
+        object instance to a network object instance.
+        """
+        self._execute_port_request(
+            lambda: self.client.port.detach(port['uuid']), port)
+
+    def add_port(self, port):
+        """
+        Sends a request to the vswitch requesting the addition of a new port
+        object instance.
+        """
+        result = self._execute_port_request(
+            lambda: self.client.port.create(port), port)
+        self.vif_created(port['uuid'])
+        return result
+
+    def update_port(self, port):
+        """
+        Sends a request to the vswitch requesting the update of a port object
+        """
+        self._execute_port_request(
+            lambda: self.client.port.update(port['uuid'], port), port)
+
+    def delete_port(self, port):
+        """
+        Sends a request to the vswitch requesting the deletion of a port
+        object instance.
+        """
+        self._execute_port_request(
+            lambda: self.client.port.delete(port['uuid']), port)
+        self.vif_deleted(port['uuid'])
+
+    def destroy_port(self, port):
+        """
+        This is an extension API to do a best-effort attempt at locking,
+        detaching, and deleting of a given port.  It exists to ignore attempts
+        at deleting ports that do not actually exist.
+        """
+        try:
+            self.lock_port(port)
+            self.detach_port(port)
+            self.delete_port(port)
+        except exceptions.VSwitchPortNotFoundError:
+            pass
+
+    def get_port_list(self):
+        """
+        Sends a request to the vswitch requesting the current list of port
+        object instances along with their attributes.
+        """
+        return self._execute_port_request(self.client.port.list)
+
+    def get_port(self, uuid):
+        """
+        Sends a request to the vswitch requesting the attributes of a port
+        object instance.
+        """
+        return self._execute_port_request(
+            lambda: self.client.port.get(uuid))
+
+    def get_port_status(self, port):
+        """
+        Retrieves the current link operational state for a given port object
+        instance.
+        """
+        data = self.get_port(port['uuid'])
+        if 'admin-state' in data and 'link-state' in data:
+            if data['admin-state'] == "down":
+                return False
+            elif data['link-state'] == "up":
+                return True
+        return False
+
+    def get_port_list_stats(self):
+        """
+        Sends a request to the vswitch requesting the current list of port
+        object instances along with their statistics
+        """
+        return self._execute_port_request(self.client.port.list_stats)
+
+    def update_interface(self, interface):
+        """
+        Sends a request to the vswitch requesting an update of an interface
+        object instance.
+        """
+        self._execute_interface_request(
+            lambda: self.client.interface.update(interface['uuid'], interface))
+
+    def attach_interface(self, interface):
+        """
+        Sends a request to the vswitch requesting the attachment of a
+        interface object instance to a network object instance.
+        """
+        self._execute_interface_request(
+            lambda: self.client.interface.attach(
+                interface['uuid'], interface['network-uuid']), interface)
+
+    def detach_interface(self, interface):
+        """
+        Sends a request to the vswitch requesting the attachment of a
+        interface object instance to a network object instance.
+        """
+        self._execute_interface_request(
+            lambda: self.client.interface.detach(interface['uuid']), interface)
+
+    def add_interface(self, interface):
+        """
+        Sends a request to the vswitch requesting the addition of a new
+        interface object instance.
+        """
+        return self._execute_interface_request(
+            lambda: self.client.interface.create(interface), interface)
+
+    def delete_interface(self, interface):
+        """
+        Sends a request to the vswitch requesting the deletion of a interface
+        object instance.
+        """
+        self._execute_interface_request(
+            lambda: self.client.interface.delete(interface['uuid']), interface)
+
+    def get_interface_list(self):
+        """
+        Sends a request to the vswitch requesting the current list of interface
+        object instances along with their attributes.
+        """
+        return self._execute_interface_request(self.client.interface.list)
+
+    def get_interface(self, uuid):
+        """
+        Sends a request to the vswitch requesting the attributes of a interface
+        object instance.
+        """
+        return self._execute_interface_request(
+            lambda: self.client.interface.get(uuid))
+
+    def get_interface_list_stats(self):
+        """
+        Sends a request to the vswitch requesting the current list of interface
+        object instances along with their statisitcs.
+        """
+        return self._execute_interface_request(
+            self.client.interface.list_stats)
+
+    def get_lacp_interface_list(self):
+        """
+        Sends a request to the vswitch requesting the current list of LACP
+        enabled interface object instances
+        """
+        return self._execute_interface_request(self.client.lacp.interfaces)
+
+    def add_network(self, network):
+        """
+        Sends a request to the vswitch requesting the addition of a new
+        logical network object instance.
+        """
+        return self._execute_network_request(
+            lambda: self.client.network.create(network), network)
+
+    def update_network(self, network):
+        """
+        Sends a request to the vswitch requesting the update of a network
+        object
+        """
+        self._execute_network_request(
+            lambda: self.client.network.update(network['uuid'],
+                                               network), network)
+
+    def delete_network(self, network):
+        """
+        Sends a request to the vswitch requesting the deletion of a logical
+        network object instance.
+        """
+        self._execute_network_request(
+            lambda: self.client.network.delete(network['uuid']), network)
+
+    def add_network_entry(self, interface_uuid, mac_address):
+        """
+        Sends a request to the vswitch requesting a static layer2 address
+        entry against an interface.  The network is derived from the interface
+        once the request arrives at the vswitch.
+        """
+        self._execute_interface_request(
+            lambda: self.client.network.add(interface_uuid, mac_address))
+
+    def remove_network_entry(self, interface_uuid, mac_address):
+        """
+        Sends a request to the vswitch requesting the removal of a static
+        layer2 address entry against an interface.  The network is derived
+        from the interface once the request arrives at the vswitch.
+        """
+        self._execute_interface_request(
+            lambda: self.client.network.remove(interface_uuid, mac_address))
+
+    def get_network_list(self):
+        """
+        Sends a request to the vswitch requesting the current list of logical
+        network object instances along with their attributes.
+        """
+        return self._execute_network_request(self.client.network.list)
+
+    def get_network_interface_list(self, uuid):
+        """
+        Sends a request to the vswitch requesting the current list of logical
+        interface objects that are attached to the specified network object
+        instances.
+        """
+        return self._execute_interface_request(
+            lambda: self.client.interface.list_network(uuid))
+
+    def get_network(self, uuid):
+        """
+        Sends a request to the vswitch requesting the attributes of a logical
+        network object instance.
+        """
+        return self._execute_network_request(
+            lambda: self.client.network.get(uuid))
+
+    def add_filter_rule(self, rule):
+        """
+        Sends a request to the vswitch requesting the addition of a new
+        filter rule.
+        """
+        return self._execute_filter_request(
+            lambda: self.client.filter.create(rule), rule=rule)
+
+    def delete_filter_rule(self, rule):
+        """
+        Sends a request to the vswitch requesting the deletion of an existing
+        filter rule.
+        """
+        self._execute_filter_request(
+            lambda: self.client.filter.delete(rule['uuid']), rule=rule)
+
+    def add_filter_binding(self, rule, port_uuid):
+        """
+        Sends a request to the vswitch requesting the addition of a new
+        filter binding.
+        """
+        return self._execute_filter_request(
+            lambda: self.client.filter.bind(
+                rule['uuid'], port_uuid), rule=rule, port=port_uuid)
+
+    def delete_filter_binding(self, rule, port_uuid):
+        """
+        Sends a request to the vswitch requesting the deletion of an existing
+        filter binding.
+        """
+        self._execute_filter_request(
+            lambda: self.client.filter.unbind(
+                rule['uuid'], port_uuid), rule=rule, port=port_uuid)
+
+    def get_filter_bindings(self, port_uuid):
+        """
+        Sends a request to the vswitch requesting the current list of filter
+        rule bindings for the supplied port
+        """
+        return self._execute_filter_request(
+            lambda: self.client.filter.get_bindings(port_uuid), port=port_uuid)
+
+    def add_neighbour(self, neighbour):
+        """
+        Sends a request to the vswitch requesting the addition of a neighbour
+        entry to a logical interface.
+        """
+        return self._execute_neighbour_request(
+            lambda: self.client.neighbour.add(
+                neighbour['interface-uuid'], neighbour), neighbour)
+
+    def delete_neighbour(self, neighbour):
+        """
+        Sends a request to the vswitch requesting the deletion of a neighbour
+        entry from a logical interface.
+        """
+        self._execute_neighbour_request(
+            lambda: self.client.neighbour.remove(
+                neighbour['interface-uuid'], neighbour['address']), neighbour)
+
+    def get_neighbours(self, interface_uuid):
+        """
+        Sends a request to the vswitch requesting the list of neighbours on a
+        specific interface.
+        """
+        return self._execute_neighbour_request(
+            lambda: self.client.neighbour.list_interface(interface_uuid))
+
+    def add_address(self, address):
+        """
+        Sends a request to the vswitch requesting the addition of an IP
+        address to a logical interface.
+        """
+        return self._execute_address_request(
+            lambda: self.client.address.add(
+                address['interface-uuid'], address), address)
+
+    def delete_address(self, address):
+        """
+        Sends a request to the vswitch requesting the deletion of an IP
+        address from a logical interface.
+        """
+        self._execute_address_request(
+            lambda: self.client.address.remove(
+                    address['interface-uuid'],
+                    address['address']), address)
+
+    def get_address_list(self, family=None, interface_uuid=None):
+        """
+        Sends a request to the vswitch requesting the current list of logical
+        interface addresse objects along with their attributes.
+        """
+        return self._execute_address_request(
+            lambda: self.client.address.list_table(
+                family=family, interface_uuid=interface_uuid))
+
+    def add_route(self, route):
+        """
+        Sends a request to the vswitch requesting the addition of an IP
+        route.
+        """
+        router_uuid = route['router-uuid'] if 'router-uuid' in route else None
+        return self._execute_route_request(
+            lambda: self.client.route.add(route, router_uuid), route)
+
+    def replace_route(self, route):
+        """
+        Sends a request to the vswitch requesting the replacement of an IP
+        route.  If the route does not already exist, it will be added.
+        """
+        router_uuid = route['router-uuid'] if 'router-uuid' in route else None
+        return self._execute_route_request(
+            lambda: self.client.route.replace(route, router_uuid), route)
+
+    def delete_route(self, route):
+        """
+        Sends a request to the vswitch requesting the deletion of an IP
+        route.
+        """
+        router_uuid = route['router-uuid'] if 'router-uuid' in route else None
+        self._execute_route_request(
+            lambda: self.client.route.remove(
+                        route['prefix'],
+                        route['prefix-length'],
+                        router_uuid), route)
+
+    def get_router_list(self):
+        """
+        Sends a request to the vswitch requesting the current list of router
+        object instances along with their attributes.
+        """
+        return self._execute_router_request(self.client.router.list)
+
+    def get_router_interfaces(self, uuid):
+        """
+        Sends a request to the vswitch requesting a list of interfaces for the
+        supplied router
+        """
+        return self._execute_interface_request(
+            lambda: self.client.interface.list_router(uuid))
+
+    def get_router_routes(self, uuid):
+        """
+        Sends a request to the vswitch requesting a list of routes for the
+        supplied router
+        """
+        return self._execute_route_request(
+            lambda: self.client.route.list_table(router=uuid))
+
+    def get_router(self, uuid):
+        """
+        Sends a request to the vswitch requesting the attributes of a virtual
+        router object instance.
+        """
+        return self._execute_router_request(
+            lambda: self.client.router.get(uuid))
+
+    def add_router(self, router):
+        """
+        Sends a request to the vswitch requesting the addition of a
+        router.
+        """
+        return self._execute_router_request(
+            lambda: self.client.router.create(router), router)
+
+    def update_router(self, router):
+        """
+        Sends a request to the vswitch requesting the update of a
+        router.
+        """
+        return self._execute_router_request(
+            lambda: self.client.router.update(router['uuid'], router), router)
+
+    def delete_router(self, router):
+        """
+        Sends a request to the vswitch requesting the deletion of a router.
+        """
+        self._execute_router_request(
+            lambda: self.client.router.delete(router['uuid']), router)
+
+    def router_attach_interface(self, router):
+        """
+        Sends a request to the vswitch requesting the attachment of an
+        interface object instance to a router object instance.
+        """
+        self._execute_router_request(
+            lambda: self.client.router.attach(
+                router['uuid'], router['interface-uuid']), router)
+
+    def router_detach_interface(self, router):
+        """
+        Sends a request to the vswitch requesting the attachment of a
+        interface object instance to a router object instance.
+        """
+        self._execute_router_request(
+            lambda: self.client.router.detach(
+                router['uuid'], router['interface-uuid']), router)
+
+    def get_dvr_host_macs(self):
+        """
+        Sends a request to the vswitch requesting the current set of known
+        unique MAC addresses.
+        """
+        return self._execute_dvr_request(self.client.dvr.list_host_macs)
+
+    def update_dvr_host_macs(self, host_macs):
+        """
+        Sends a request to the vswitch notifying it that the list of unique
+        MAC addresses has changed.
+        """
+        self._execute_dvr_request(
+            lambda: self.client.dvr.update_host_macs(host_macs))
+
+    def add_snat_entry(self, snat):
+        """
+        Sends a request to the vswitch requesting the addition of a static IPv4
+        SNAT entry.
+        """
+        return self._execute_snat_request(
+            lambda: self.client.snat.create(snat), snat)
+
+    def delete_snat_entry(self, interface_uuid, src_address, src_port,
+                          protocol):
+        """
+        Sends a request to the vswitch requesting the deletion of a static IPv4
+        SNAT entry.
+        """
+        self._execute_snat_request(
+            lambda: self.client.snat.delete(interface_uuid, src_address,
+                                            src_port, protocol))
+
+    def get_snat_list(self):
+        """
+        Sends a request to the vswitch requesting the full list of IPv4 SNAT
+        entries.
+        """
+        return self._execute_snat_request(
+            self.client.snat.list_table)
+
+    def send_ping_request(self, body):
+        """
+        Sends a request to the vswitch requesting to ping the given address
+        """
+        return self._execute_ping_request(
+            lambda: self.client.ping.send(body))
+
+    def get_ping_response(self, ping_id):
+        """
+        Gets the response from a given ping from vswitch
+        """
+        return self._execute_ping_request(
+            lambda: self.client.ping.get(ping_id))
diff --git a/neutron/agent/vswitch/constants.py b/neutron/agent/vswitch/constants.py
new file mode 100644
index 0000000..2d91994
--- /dev/null
+++ b/neutron/agent/vswitch/constants.py
@@ -0,0 +1,100 @@
+# Copyright 2012 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+#
+# Copyright (c) 2013-2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+from vswitchclient import constants
+
+# Client parameters
+VSWITCH_CLIENT_VERSION = "1"
+VSWITCH_CLIENT_ENDPOINT = constants.VSWITCHCLIENT_URL
+
+# vswitch port types
+VSWITCH_PHYSICAL_PORT = "physical"
+VSWITCH_AVP_GUEST_PORT = "avp-guest"
+VSWITCH_AVP_HOST_PORT = "avp-host"
+
+VSWITCH_DVR_SERVICED_PORTS = [VSWITCH_AVP_GUEST_PORT, VSWITCH_AVP_HOST_PORT]
+
+# vswitch network types
+VSWITCH_LAYER2_NETWORK = "layer2"
+
+# vswitch interface types
+VSWITCH_AE_INTERFACE = "ae"
+VSWITCH_ETHERNET_INTERFACE = "ethernet"
+VSWITCH_VLAN_INTERFACE = "vlan"
+VSWITCH_VXLAN_INTERFACE = "vxlan"
+VSWITCH_ROUTER_INTERFACE = "router"
+
+# vswitch interface classes
+VSWITCH_PROVIDER_INTERFACE = "provider"
+VSWITCH_TENANT_INTERFACE = "tenant"
+VSWITCH_HOST_INTERFACE = "host"
+
+# vswitch port admin states
+VSWITCH_ADMIN_STATE_UP = "up"
+VSWITCH_ADMIN_STATE_DOWN = "down"
+
+# vswitch port link states
+VSWITCH_LINK_STATE_UP = "up"
+VSWITCH_LINK_STATE_DOWN = "down"
+
+# vswitch AE member states
+VSWITCH_AE_MEMBER_STATE_ACTIVE = "active"
+VSWITCH_AE_MEMBER_STATE_STANDBY = "standby"
+VSWITCH_AE_MEMBER_STATE_DOWN = "down"
+
+# vswitch AE protection modes
+VSWITCH_AE_PROTECTION_MODE_FAILOVER = "failover"
+VSWITCH_AE_PROTECTION_MODE_LOADBALANCE = "loadbalance"
+VSWITCH_AE_PROTECTION_MODE_8023AD = "802.3ad"
+
+# vswitch LACP states
+VSWITCH_LACP_STATE_COLLECTING = "collecting"
+VSWITCH_LACP_STATE_DISTRIBUTING = "distributing"
+
+# vswitch threshold for stale ports
+VSWITCH_STALE_PORT_THRESHOLD_MINS = 5
+
+# vswitch NUMA socket identifiers
+VSWITCH_SOCKET_ID_0 = 0
+VSWITCH_SOCKET_ID_1 = 1
+
+# vswitch NDP router advertisement modes
+VSWITCH_NDP_RA_MODE_NONE = None
+VSWITCH_NDP_RA_MODE_SLAAC = "slaac"
+VSWITCH_NDP_RA_MODE_STATELESS = "stateless"
+VSWITCH_NDP_RA_MODE_STATEFUL = "stateful"
+
+# vswitch neighbour types
+VSWITCH_NEIGH_STATIC = "static"
+VSWITCH_NEIGH_DYNAMIC = "dynamic"
+
+# vswitch number of bytes overhead for ICMP packet
+VSWITCH_IPV6_ICMP_HEADER_SIZE = 48
+
+# vswitch minimum ping size to try
+VSWITCH_PING_MINIMUM_SIZE = 64
+
+# vswitch get_ping_response wait time parameters
+VSWITCH_PING_RESPONSE_CHECK_INTERVAL = 0.0025
+VSWITCH_PING_RESPONSE_CHECK_MULTIPLIER = 2.0
+VSWITCH_PING_RESPONSE_CHECK_COUNT = 10
diff --git a/neutron/agent/vswitch/exceptions.py b/neutron/agent/vswitch/exceptions.py
new file mode 100644
index 0000000..d4382f8
--- /dev/null
+++ b/neutron/agent/vswitch/exceptions.py
@@ -0,0 +1,411 @@
+# Copyright 2012 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2014 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+
+class VSwitchError(Exception):
+    """
+    Base exception class for all VSwitch errors.
+    """
+    def __init__(self, message):
+        self.message = message
+
+    def __str__(self):
+        return "{}".format(self.message)
+
+
+class VSwitchCommunicationError(VSwitchError):
+    """
+    Exception raised to signal errors communicating with the vswitch server
+    process.
+    """
+    def __init__(self, message):
+        super(VSwitchCommunicationError, self).__init__(message)
+
+
+class VSwitchEngineError(VSwitchError):
+    """
+    Exception raised to signal errors during port operations.
+    """
+    def __init__(self, message, engine):
+        super(VSwitchEngineError, self).__init__(message)
+        self.engine = engine
+
+    def __str__(self):
+        if self.engine:
+            return "request failed with error {} on engine {}".format(
+                self.message, self.engine['id'])
+        else:
+            return "request failed with error {}".format(self.message)
+
+
+class VSwitchEngineNotFoundError(VSwitchEngineError):
+    """
+    Exception raised to signal that a engine operation targeted a non-existent
+    engine object instance.
+    """
+    def __init__(self, message, engine):
+        super(VSwitchEngineNotFoundError, self).__init__(message, engine)
+
+
+class VSwitchPortError(VSwitchError):
+    """
+    Exception raised to signal errors during port operations.
+    """
+    def __init__(self, message, port):
+        super(VSwitchPortError, self).__init__(message)
+        self.port = port
+
+    def __str__(self):
+        if self.port:
+            return "request failed with error {} on port {}".format(
+                self.message, self.port['uuid'])
+        else:
+            return "request failed with error {}".format(self.message)
+
+
+class VSwitchPortNotFoundError(VSwitchPortError):
+    """
+    Exception raised to signal that a port operation targeted a non-existent
+    port object instance.
+    """
+    def __init__(self, message, port):
+        super(VSwitchPortNotFoundError, self).__init__(message, port)
+
+
+class VSwitchPortRetryNeeded(VSwitchPortError):
+    """
+    Exception raised to signal that a port operation was rejected due to
+    contention at the server.  A retry is needed.
+    """
+    def __init__(self, message, port):
+        super(VSwitchPortRetryNeeded, self).__init__(message, port)
+
+
+class VSwitchNetworkError(VSwitchError):
+    """
+    Exception raised to signal errors during network operations.
+    """
+    def __init__(self, message, network):
+        super(VSwitchNetworkError, self).__init__(message)
+        self.network = network
+
+    def __str__(self):
+        if self.network:
+            return "request failed with error {} on network {}".format(
+                self.message, self.network['uuid'])
+        else:
+            return "request failed with error {}".format(self.message)
+
+
+class VSwitchNetworkNotFoundError(VSwitchNetworkError):
+    """
+    Exception raised to signal that a network operation targeted a non-existent
+    network object instance.
+    """
+    def __init__(self, message, network):
+        super(VSwitchNetworkNotFoundError, self).__init__(
+            message, network)
+
+
+class VSwitchInterfaceError(VSwitchError):
+    """
+    Exception raised to signal errors during interface operations.
+    """
+    def __init__(self, message, interface):
+        super(VSwitchInterfaceError, self).__init__(message)
+        self.interface = interface
+
+    def __str__(self):
+        if self.interface:
+            return "request failed with error {} on interface {}".format(
+                self.message, self.interface['uuid'])
+        else:
+            return "request failed with error {}".format(self.message)
+
+
+class VSwitchInterfaceNotFoundError(VSwitchInterfaceError):
+    """
+    Exception raised to signal that a interface operation targeted a
+    non-existent interface object instance.
+    """
+    def __init__(self, message, interface):
+        super(VSwitchInterfaceNotFoundError, self).__init__(
+            message, interface)
+
+
+class VSwitchFilterError(VSwitchError):
+    """
+    Exception raised to signal errors during filter operations.
+    """
+    def __init__(self, message, rule, port):
+        super(VSwitchFilterError, self).__init__(message)
+        self.rule = rule
+        self.port = port
+
+    def __str__(self):
+        if self.rule and self.port:
+            msg = ("request failed with error {} on "
+                   "filter rule {} and port {}".format(
+                       self.message, self.rule['uuid'], self.port))
+        elif self.rule:
+            msg = ("request failed with error {} on "
+                   "filter rule {}".format(
+                       self.message, self.rule['uuid']))
+        elif self.port:
+            msg = ("request failed with error {} on "
+                   "filter port {}".format(
+                       self.message, self.port))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchFilterNotFoundError(VSwitchFilterError):
+    """
+    Exception raised to signal that a filter operation targeted a non-existent
+    filter object instance.
+    """
+    def __init__(self, message, rule, port):
+        super(VSwitchFilterNotFoundError, self).__init__(
+            message, rule, port)
+
+
+class VSwitchFilterForbiddenError(VSwitchFilterError):
+    """
+    Exception raised to signal that a filter operation is not permitted.
+    """
+    def __init__(self, message, rule, port):
+        super(VSwitchFilterForbiddenError, self).__init__(
+            message, rule, port)
+
+
+class VSwitchNeighbourError(VSwitchError):
+    """
+    Exception raised to signal errors during neighbour operations.
+    """
+    def __init__(self, message, neighbour):
+        super(VSwitchNeighbourError, self).__init__(message)
+        self.interface = getattr(neighbour, 'interface-uuid', None)
+        self.neighbour = neighbour
+
+    def __str__(self):
+        if self.interface and self.neighbour:
+            msg = (
+                "request failed with error {} for "
+                "neighbour {} on interface {}".format(
+                    self.message, self.neighbour, self.interface))
+        elif self.neighbour:
+            msg = (
+                "request failed with error {} on "
+                "neighbour {}".format(
+                    self.message, self.neighbour))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchNeighbourNotFoundError(VSwitchNeighbourError):
+    """
+    Exception raised to signal that a neighbour operation targeted a
+    non-existent neighbour object instance.
+    """
+    def __init__(self, message, neighbour):
+        super(VSwitchNeighbourNotFoundError, self).__init__(
+            message, neighbour)
+
+
+class VSwitchNeighbourForbiddenError(VSwitchNeighbourError):
+    """
+    Exception raised to signal that a neighbour operation is not permitted.
+    """
+    def __init__(self, message, neighbour):
+        super(VSwitchNeighbourForbiddenError, self).__init__(
+            message, neighbour)
+
+
+class VSwitchAddressError(VSwitchError):
+    """
+    Exception raised to signal errors during address operations.
+    """
+    def __init__(self, message, address):
+        super(VSwitchAddressError, self).__init__(message)
+        self.interface = getattr(address, 'interface-uuid', None)
+        self.address = address
+
+    def __str__(self):
+        if self.interface and self.address:
+            msg = (
+                "request failed with error {} for "
+                "address {} on interface {}".format(
+                    self.message, self.address, self.interface))
+        elif self.address:
+            msg = (
+                "request failed with error {} on "
+                "address {}".format(
+                    self.message, self.address))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchAddressNotFoundError(VSwitchAddressError):
+    """
+    Exception raised to signal that a address operation targeted a non-existent
+    address object instance.
+    """
+    def __init__(self, message, address):
+        super(VSwitchAddressNotFoundError, self).__init__(
+            message, address)
+
+
+class VSwitchAddressForbiddenError(VSwitchAddressError):
+    """
+    Exception raised to signal that a address operation is not permitted.
+    """
+    def __init__(self, message, address):
+        super(VSwitchAddressForbiddenError, self).__init__(
+            message, address)
+
+
+class VSwitchRouteError(VSwitchError):
+    """
+    Exception raised to signal errors during route operations.
+    """
+    def __init__(self, message, route):
+        super(VSwitchRouteError, self).__init__(message)
+        self.route = route
+
+    def __str__(self):
+        if self.route:
+            msg = ("request failed with error {} on "
+                   "route {}".format(
+                       self.message, self.route))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchRouteNotFoundError(VSwitchRouteError):
+    """
+    Exception raised to signal that a route operation targeted a non-existent
+    route object instance.
+    """
+    def __init__(self, message, route):
+        super(VSwitchRouteNotFoundError, self).__init__(
+            message, route)
+
+
+class VSwitchRouteForbiddenError(VSwitchRouteError):
+    """
+    Exception raised to signal that a route operation is not permitted.
+    """
+    def __init__(self, message, route):
+        super(VSwitchRouteForbiddenError, self).__init__(
+            message, route)
+
+
+class VSwitchRouterError(VSwitchError):
+    """
+    Exception raised to signal errors during router operations.
+    """
+    def __init__(self, message, router):
+        super(VSwitchRouterError, self).__init__(message)
+        self.router = router
+
+    def __str__(self):
+        if self.router:
+            msg = ("request failed with error {} on "
+                   "router {}".format(
+                       self.message, self.router))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchRouterNotFoundError(VSwitchRouterError):
+    """
+    Exception raised to signal that a router operation targeted a non-existent
+    router object instance.
+    """
+    def __init__(self, message, router):
+        super(VSwitchRouterNotFoundError, self).__init__(
+            message, router)
+
+
+class VSwitchRouterForbiddenError(VSwitchRouterError):
+    """
+    Exception raised to signal that a router operation is not permitted.
+    """
+    def __init__(self, message, router):
+        super(VSwitchRouterForbiddenError, self).__init__(
+            message, router)
+
+
+class VSwitchDvrError(VSwitchError):
+    """
+    Exception raised to signal errors during DVR operations.
+    """
+    def __init__(self, message):
+        super(VSwitchDvrError, self).__init__(message)
+
+    def __str__(self):
+        msg = "DVR request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchSnatError(VSwitchError):
+    """
+    Exception raised to signal errors during SNAT operations.
+    """
+    def __init__(self, message, snat):
+        super(VSwitchSnatError, self).__init__(message)
+        self.snat = snat
+
+    def __str__(self):
+        if self.snat:
+            msg = ("request failed with error {} on "
+                   "snat {}".format(
+                       self.message, self.snat))
+        else:
+            msg = "request failed with error {}".format(self.message)
+        return msg
+
+
+class VSwitchSnatNotFoundError(VSwitchSnatError):
+    """
+    Exception raised to signal that a SNAT operation targeted a non-existent
+    SNAT object instance.
+    """
+    def __init__(self, message, snat):
+        super(VSwitchSnatNotFoundError, self).__init__(
+            message, snat)
+
+
+class VSwitchSnatPortBusyError(VSwitchSnatError):
+    """
+    Exception raised to signal that a SNAT operation targeted a non-existent
+    address and port combination that is already in use by another static SNAT
+    entry.
+    """
+    def __init__(self, message, snat):
+        super(VSwitchSnatPortBusyError, self).__init__(
+            message, snat)
diff --git a/neutron/agent/vswitch/interface.py b/neutron/agent/vswitch/interface.py
new file mode 100644
index 0000000..85097f7
--- /dev/null
+++ b/neutron/agent/vswitch/interface.py
@@ -0,0 +1,119 @@
+# Copyright 2012 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2014 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+from oslo_log import log as logging
+
+from neutron.agent.linux import interface
+from neutron.agent.linux import ip_lib
+from neutron.agent.vswitch import api
+from neutron.agent.vswitch import constants
+from neutron.agent.vswitch import exceptions
+
+
+LOG = logging.getLogger(__name__)
+
+
+class VSwitchInterfaceDriver(interface.LinuxInterfaceDriver):
+
+    DEV_NAME_PREFIX = 'avp'
+
+    def __init__(self, conf):
+        super(VSwitchInterfaceDriver, self).__init__(conf)
+        self.api = api.VSwitchManagementAPI()
+
+    def _find_port_by_device_name(self, device_name):
+        for port in self.api.get_port_list():
+            prefix = device_name[len(self.DEV_NAME_PREFIX):]
+            if port['uuid'].startswith(prefix):
+                return port
+        return None
+
+    def plug_new(self, network_id, port_id, device_name, mac_address,
+                 bridge=None, namespace=None, prefix=None, mtu=None):
+        """Plugin the interface."""
+        LOG.debug("plug() %(network_id)s %(port_id)s "
+                  "%(device_name)s %(mac_address)s"
+                  "%(bridge)s %(namespace)s %(prefix)s",
+                  {'network_id': network_id, 'port_id': port_id,
+                   'device_name': device_name, 'mac_address': mac_address,
+                   'bridge': bridge, 'namespace': namespace, 'prefix': prefix})
+
+        ip = ip_lib.IPWrapper()
+        if not ip_lib.device_exists(device_name,
+                                    namespace=namespace):
+            port = {'type': constants.VSWITCH_AVP_HOST_PORT,
+                    'device-name': device_name,
+                    'uuid': port_id,
+                    'mac-address': mac_address,
+                    'network-uuid': network_id,
+                    'mtu': mtu,
+                    'neutron': True}
+            try:
+                # Attempt to create
+                self.api.add_port(port)
+            except exceptions.VSwitchError as e:
+                LOG.error("Failed to create port {}, {}".format(
+                    port_id, e))
+                raise
+
+            # Do not unlock or attach the port.  The L2 agent will do it
+            LOG.info("Device %s has been created", device_name)
+
+            # Get a reference to the device and create NS if necessary
+            device = ip.device(device_name)
+            ip_ns = ip.ensure_namespace(namespace)
+
+            # Attempt to move the device to a namespace
+            ip_ns.add_device_to_namespace(device)
+            LOG.info("Device %(name)s has been added "
+                     "to namespace %(namespace)s",
+                     {'name': device_name, 'namespace': namespace})
+        else:
+            device = ip.device(device_name)
+            LOG.warning("Device %s already exists", device_name)
+
+        # Attempt to set the interface MTU
+        mtu_value = mtu if mtu else self.conf.network_device_mtu
+        if mtu_value:
+            device.link.set_mtu(mtu_value)
+        # Attempt to bring up linux interface
+        device.link.set_up()
+        LOG.info("Device %s has been set to up", device_name)
+
+    def unplug(self, device_name, bridge=None, namespace=None, prefix=None):
+        """Unplug the interface."""
+        LOG.debug("unplug() %(device_name)s %(bridge)s "
+                  "%(namespace)s %(prefix)s",
+                  {'device_name': device_name, 'bridge': bridge,
+                   'namespace': namespace, 'prefix': prefix})
+        port = self._find_port_by_device_name(device_name)
+        if not port:
+            LOG.info("Device %s has already been deleted", device_name)
+            return
+        try:
+            # Attempt to lock, detach and delete the port
+            self.api.destroy_port(port)
+            LOG.info("Device %s has been deleted", device_name)
+        except exceptions.VSwitchError as e:
+            LOG.error("Failed to detach port {}, {}".format(
+                      port['uuid'], e))
+            raise
diff --git a/neutron/agent/vswitch/manager.py b/neutron/agent/vswitch/manager.py
new file mode 100644
index 0000000..b80800b
--- /dev/null
+++ b/neutron/agent/vswitch/manager.py
@@ -0,0 +1,1314 @@
+#!/usr/bin/env python
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2016 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+
+import collections
+import re
+import time
+import uuid
+
+from neutron_lib import constants
+from oslo_log import log as logging
+import six
+from tsconfig import tsconfig
+
+from neutron.agent.vswitch import constants as avs_constants
+from neutron.agent.vswitch import exceptions
+from neutron.common import constants as n_const
+
+
+LOG = logging.getLogger(__name__)
+
+AVS_NAT_PROTOCOLS = {
+    constants.PROTO_NAME_TCP: 'tcp',
+    constants.PROTO_NAME_UDP: 'udp',
+    constants.PROTO_NAME_UDPLITE: 'udp-lite',
+    constants.PROTO_NAME_SCTP: 'sctp',
+    constants.PROTO_NAME_DCCP: 'dccp',
+    constants.PROTO_NAME_ICMP: 'icmp'}
+
+
+def port_sort_key(port):
+    """
+    Sort ports by their created-timetamp so that older ports are treated
+    first.  This is to ensure that we get to a port as soon as possible after
+    it has been created by nova, or by one of the agents.
+    """
+    return port['created-timestamp']
+
+
+def interface_sort_key(iface):
+    """
+    Sort interfaces by interface type placing aggregated ethernet interfaces
+    ahead of ethernet interfaces, and vlan interfaces last.  This is to satisfy
+    processing of the 'upper-uuid' and 'lower-uuid' attributes which need to
+    refer to interfaces that have already been processed.
+
+    Use the created-timestamp as the secondary key to ensure that older
+    interfaces are treated first so that they are handled as soon as possible
+    after they have been created by an agent.
+    """
+    if iface['type'] == avs_constants.VSWITCH_AE_INTERFACE:
+        return (0, iface['created-timestamp'])
+    elif iface['type'] == avs_constants.VSWITCH_ETHERNET_INTERFACE:
+        return (1, iface['created-timestamp'])
+    else:  # if iface['type'] == avs_constants.VSWITCH_VLAN_INTERFACE:
+        return (2, iface['created-timestamp'])
+
+
+class VSwitchManagerError(Exception):
+    """
+    Errors reported from the manager layer.
+    """
+    def __init__(self, message):
+        self.message = message
+
+    def __str__(self):
+        return "{}".format(self.message)
+
+
+class VSwitchManager(object):
+    """
+    Abstraction layer to handle interactions between the Agent and the API.
+    Incoming parameters are expected to be in openstack format and converted
+    to vswitch equivalents before being passed to the API.
+    """
+
+    def __init__(self, api, mappings=None):
+        self.api = api
+        self.interface_mappings = mappings or {}
+
+    def add_port(self, uuid, device_name, mac_address, mtu, neutron=True):
+        port = {'type': avs_constants.VSWITCH_AVP_HOST_PORT,
+                'device-name': device_name,
+                'uuid': uuid,
+                'mac-address': mac_address,
+                'mtu': mtu,
+                'neutron': neutron}
+        LOG.debug("Adding port {}".format(port))
+        try:
+            # Attempt to create
+            self.api.add_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add port {}, {}".format(port, e))
+
+    def unlock_port(self, uuid):
+        """
+        Unlock a vswitch port.
+        """
+        LOG.debug("Unlocking port {}".format(uuid))
+        port = {'uuid': uuid}
+        try:
+            self.api.unlock_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to unlock port {}, {}".format(port['uuid'], e))
+
+    def lock_port(self, uuid):
+        """
+        Lock a vswitch port.
+        """
+        LOG.debug("Locking port {}".format(uuid))
+        port = {'uuid': uuid}
+        try:
+            self.api.lock_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to lock port {}, {}".format(port['uuid'], e))
+
+    def update_port(self, uuid, params):
+        """
+        Update a vswitch port parameters.
+        """
+        LOG.debug("Updating port {} {}".format(uuid, params))
+        port = {'uuid': uuid}
+        port.update(params)
+        try:
+            self.api.update_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to update port {}, {}".format(port['uuid'], e))
+
+    def destroy_port(self, uuid):
+        """
+        Destroy a vswitch port by locking, detaching and then deleting the port
+        """
+        LOG.debug("Destroy port {}".format(uuid))
+        port = {'uuid': uuid}
+        try:
+            self.api.destroy_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to destroy port {}, {}".format(port['uuid'], e))
+
+    def attach_port(self, uuid, network_uuid):
+        """
+        Attach a vswitch port to a network segment.
+        """
+        LOG.debug("Attaching port {} to network {}".format(uuid, network_uuid))
+        port = {'uuid': uuid, "network-uuid": network_uuid}
+        try:
+            self.api.attach_port(port)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to attach port {}, {}".format(port['uuid'], e))
+
+    def update_interface(self, uuid, params):
+        """
+        Update vswitch interface parameters.
+        """
+        LOG.debug("Updating port {} {}".format(uuid, params))
+        interface = {'uuid': uuid}
+        interface.update(params)
+        try:
+            self.api.update_interface(interface)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to update interface {}, {}".format(
+                    interface['uuid'], e))
+
+    def get_interface(self, uuid):
+        """
+        Obtain an interface object by uuid.
+        """
+        try:
+            return self.api.get_interface(uuid)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to query interface {}, {}".format(uuid, e))
+
+    def find_interface(self, name):
+        """
+        Lookup an interface object by name.
+        """
+        try:
+            for interface in self.api.get_interface_list():
+                if name == interface['name']:
+                    return interface
+            return None
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to query interface list, {}".format(e))
+
+    def add_vlan_interface(self, uuid, vlan_id, mtu, lower_uuid):
+        """
+        Create new vlan interface.
+        """
+        interface = {
+            'type': avs_constants.VSWITCH_VLAN_INTERFACE,
+            'mtu': mtu,
+            'uuid': uuid,
+            'vlan-id': vlan_id,
+            'lower-uuid': lower_uuid,
+        }
+        try:
+            self.api.add_interface(interface)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add vlan interface {}, {}".format(interface, e))
+
+    def add_vxlan_interface(self, uuid, vxlan_id, group, port, ttl, mtu,
+                            lower_uuid):
+        """
+        Create new vxlan interface.
+        """
+        interface = {
+            'type': avs_constants.VSWITCH_VXLAN_INTERFACE,
+            'group': group,
+            'port': port,
+            'mtu': mtu,
+            'ttl': ttl,
+            'uuid': uuid,
+            'vxlan-id': vxlan_id,
+            'lower-uuid': lower_uuid,
+        }
+        try:
+            self.api.add_interface(interface)
+        except exceptions.VSwitchError as e:
+            msg = "Failed to add vxlan interface {}, {}".format(
+                interface, e)
+            raise VSwitchManagerError(msg)
+
+    def add_router_interface(self, uuid, router_uuid, mac_address, mtu,
+                             **kwargs):
+        """
+        Create a new router interface for the supplied router
+        """
+        # Determine if the interface already exists
+        try:
+            interface = self.get_interface(uuid)
+        except VSwitchManagerError:
+            interface = None
+        if not interface:
+            # Create new router interface
+            interface = {
+                'type': avs_constants.VSWITCH_ROUTER_INTERFACE,
+                'uuid': uuid,
+                'mac-address': mac_address,
+                'mtu': mtu,
+                'router-uuid': router_uuid,
+                'neutron': True,
+            }
+            for arg in kwargs.keys():
+                if kwargs[arg] is not None:
+                    interface[arg] = kwargs[arg]
+            try:
+                self.api.add_interface(interface)
+            except exceptions.VSwitchError as e:
+                raise VSwitchManagerError(
+                    "Failed to add router interface {}, {}".format(
+                        interface, e))
+
+    def delete_interface(self, uuid):
+        """
+        Delete an existing logical interface
+        """
+        try:
+            interface = self.get_interface(uuid)
+        except VSwitchManagerError:
+            interface = None
+        if interface:
+            try:
+                self.api.delete_interface(interface)
+            except exceptions.VSwitchError as e:
+                raise VSwitchManagerError(
+                    "Failed to delete interface {}, {}".format(interface, e))
+
+    def attach_interface(self, uuid, network_uuid):
+        """
+        Attach a vswitch interface to a network segment.
+        """
+        LOG.debug("Attaching interface {} to network {}".format(
+            uuid, network_uuid))
+
+        interface = {'uuid': uuid, "network-uuid": network_uuid}
+        try:
+            self.api.attach_interface(interface)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to attach interface {}, {}".format(
+                    interface['uuid'], e))
+
+    def get_logical_interface(self, physical_network):
+        """
+        Retrieve the logical interface name which provides service to the
+        specified provider network (physical network).
+        """
+        value = self.interface_mappings.get(physical_network)
+        if not value:
+            msg = "No interface mapping for {}".format(physical_network)
+            raise VSwitchManagerError(msg)
+        result = re.search('port(\\d+)', value)
+        if result and len(result.groups()) == 1:
+            # backward compatibility to old mapping format
+            matches = result.groups()
+            return self.find_interface("eth{}".format(matches[0]))
+        return self.get_interface(value)
+
+    def get_network_name(self, network_uuid, vlan_id=None):
+        """
+        The plugin does not send us the network name therefore we build one
+        based on the network uuid.
+        """
+        name = "net-" + network_uuid[:8]
+        if vlan_id:
+            name = name + "-" + str(vlan_id)
+        return name
+
+    def _setup_flat_provider_interface(self, lower_iface, data):
+        """
+        Flat provider networks do not add any additional protocol encapsulation
+        so there is no addition interface to create (ie. vlan, vxlan, gre,
+        etc...).
+        """
+        return lower_iface['uuid']
+
+    def _setup_vlan_provider_interface(self, lower_iface, data):
+        """
+        Attach the network to a VLAN interface which is first created atop the
+        logical interface which implements the provider network.
+        """
+        iface_uuid = data['uuid']
+        vlan_id = data['segmentation_id']
+        # Query the MTU from the provider
+        mtu = data['mtu']
+        if not mtu:
+            msg = "Missing MTU for vlan provider interface: {}".format(data)
+            raise VSwitchManagerError(msg)
+        self.add_vlan_interface(iface_uuid,
+                                vlan_id,
+                                mtu,
+                                lower_iface['uuid'])
+        return iface_uuid
+
+    def _setup_vxlan_provider_interface(self, lower_iface, data):
+        """
+        Attach the network to a VLAN interface which is first created atop the
+        logical interface which implements the provider network.
+        """
+        iface_uuid = data['uuid']
+        vxlan_id = data['segmentation_id']
+        vxlan = data['vxlan']
+        # Query the MTU from the provider
+        mtu = data['mtu']
+        if not mtu:
+            msg = "Missing MTU for vxlan provider interface: {}".format(data)
+            raise VSwitchManagerError(msg)
+
+        self.add_vxlan_interface(iface_uuid,
+                                 vxlan_id,
+                                 vxlan['group'],
+                                 vxlan['port'],
+                                 vxlan['ttl'],
+                                 mtu,
+                                 lower_iface['uuid'])
+        return iface_uuid
+
+    def setup_provider_interface(self, lower_uuid, data):
+        """
+        Create and a new logical interface which implements the provider
+        segment (e.g., vlan, vxlan, gre, etc...) on the provider network.
+        """
+        lower_iface = self.get_interface(lower_uuid)
+        if not lower_iface:
+            msg = "Missing lower interface {} for provider network: {}".format(
+                lower_uuid, data)
+            raise VSwitchManagerError(msg)
+        network_type = data['network_type']
+        data['uuid'] = self.get_provider_interface_uuid(
+            lower_uuid, network_type, data.get('segmentation_id'))
+        if network_type == n_const.PROVIDERNET_VLAN:
+            return self._setup_vlan_provider_interface(lower_iface, data)
+        elif network_type == n_const.PROVIDERNET_VXLAN:
+            return self._setup_vxlan_provider_interface(lower_iface, data)
+        elif network_type == n_const.PROVIDERNET_FLAT:
+            return self._setup_flat_provider_interface(lower_iface, data)
+        else:
+            msg = "Unsupported provider network type {}".format(network_type)
+            raise VSwitchManagerError(msg)
+
+    def setup_network(self, network_uuid, network):
+        """
+        This is a utility wrapper to create a network and its provider
+        interface.
+        """
+        try:
+            nw_instance = self.get_network(network_uuid)
+        except VSwitchManagerError:
+            nw_instance = None
+        if not nw_instance:
+            nw_instance = self.add_network(network_uuid, network)
+        physical_uuid = self.get_physical_interface_uuid(
+            network['physical_network'])
+        provider_uuid = self.get_provider_interface_uuid(
+            physical_uuid,
+            network['network_type'],
+            network['segmentation_id'])
+        try:
+            instance = self.get_interface(provider_uuid)
+        except VSwitchManagerError:
+            instance = None
+        if not instance:
+            provider_uuid = self.setup_provider_interface(physical_uuid,
+                    network)
+        self.attach_interface(provider_uuid, network_uuid)
+        return provider_uuid, nw_instance
+
+    def add_network(self, uuid, network):
+        """
+        Add a new logical network segment to the vswitch.
+        """
+        LOG.debug("Adding network {}".format(network))
+
+        # Obtain the UUID of the physical network to identify the provider
+        # network that this network is associated with
+        physical_uuid = self.get_physical_interface_uuid(
+            network['physical_network'])
+
+        # Setup the network
+        network = {
+            'uuid': uuid,
+            'name': network['name'],
+            'type': network.get('type', avs_constants.VSWITCH_LAYER2_NETWORK),
+            'provider-uuid': physical_uuid,
+            'vlan-transparent': network.get('vlan_transparent', False)}
+
+        try:
+            self.api.add_network(network)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add network {}, {}".format(network['uuid'], e))
+
+    def update_network(self, uuid, params):
+        """
+        Update a vswitch port parameters.
+        """
+        LOG.debug("Updating network {} {}".format(uuid, params))
+        network = {'uuid': uuid}
+        network.update(params)
+        try:
+            self.api.update_network(network)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to update network {}, {}".format(uuid, e))
+
+    def get_network(self, uuid):
+        """
+        Obtain an network object by uuid.
+        """
+        try:
+            return self.api.get_network(uuid)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to query network {}, {}".format(uuid, e))
+
+    def delete_network(self, uuid, in_use_interfaces=None):
+        """
+        Delete a logical network segment from the vswitch.  All attached
+        interfaces will be detached prior to deletion and any related logical
+        provider network interface (i.e., vlan, vxlan, gre, ...) will be
+        deleted.
+        """
+        LOG.debug("Deleting network {}".format(uuid))
+        in_use_interfaces = in_use_interfaces or []
+        try:
+            interfaces = self.api.get_network_interface_list(uuid)
+            # Detach all interfaces before deleting the network
+            for interface in interfaces:
+                try:
+                    self.api.detach_interface(interface)
+                    auto_delete_set = (avs_constants.VSWITCH_VLAN_INTERFACE,
+                                       avs_constants.VSWITCH_VXLAN_INTERFACE)
+                    if (interface['type'] in auto_delete_set and
+                            interface['uuid'] not in in_use_interfaces):
+                        # Delete VLANs since we initially created it.
+                        self.api.delete_interface(interface)
+                except exceptions.VSwitchError as e:
+                    msg = ("Failed to detach interface {} from {}, {}".format(
+                            interface['uuid'], uuid, e))
+                    raise VSwitchManagerError(msg)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to get interface list for {}, {}".format(uuid, e))
+
+        try:
+            # Delete the network
+            network = {'uuid': uuid}
+            self.api.delete_network(network)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to delete network {}, {}".format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def is_network_orphaned(self, uuid):
+        """
+        Determine whether a network only has provider type interfaces
+        remaining.  Any such network can be safely deleted since it is not
+        providing service to any tenant resources.
+        """
+        count = 0
+        try:
+            interfaces = self.api.get_network_interface_list(uuid)
+            for interface in interfaces:
+                ifclass = interface['class']
+                if ifclass != avs_constants.VSWITCH_PROVIDER_INTERFACE:
+                    count += 1
+            return bool(count == 0)
+        except exceptions.VSwitchNetworkNotFoundError as e:
+            # Network has already been deleted
+            pass
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to get interface list for {}, {}".format(uuid, e))
+
+    def delete_orphaned_networks(self):
+        """
+        Delete any network which only has provider type interfaces remaining.
+        Any such network can be safely deleted since it is not providing
+        service to any tenant resources.
+        """
+        try:
+            networks = self.api.get_network_list()
+            for network in networks:
+                uuid = network['uuid']
+                if self.is_network_orphaned(uuid):
+                    LOG.warning("Deleting orphaned network {}".format(uuid))
+                    self.delete_network(uuid)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to get interface list for {}, {}".format(uuid, e))
+
+    def add_network_entry(self, interface_uuid, mac_address):
+        """
+        Add a static layer2 table entry against an interface network
+        attachment. The target network is derived from the interface_uuid.
+        """
+        try:
+            return self.api.add_network_entry(interface_uuid, mac_address)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to add static entry {} on {}, {}".format(
+                    mac_address, interface_uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def remove_network_entry(self, interface_uuid, mac_address):
+        """
+        Remove a static layer2 table entry from an interface network
+        attachment.  The target network is derived from the interface_uuid.
+        """
+        try:
+            return self.api.add_network_entry(interface_uuid, mac_address)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to remove static entry {} on {}, {}".format(
+                    mac_address, interface_uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def get_networks(self):
+        """
+        Retrieve the network list.
+        """
+        try:
+            networks = self.api.get_network_list()
+            return dict((network['uuid'], network)
+                        for network in networks or [])
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to get network list for {}, {}".format(uuid, e))
+
+    def get_port_status(self, uuid):
+        """
+        Query the port status for the specified port.  If an error occurs
+        while query the port status False is returned to indicate that the
+        port is assumed to be down.
+        """
+        port = {'uuid': uuid}
+        try:
+            return self.api.get_port_status(port)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query status for port {}, {}".format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def get_port_list(self):
+        """
+        Retrieve the current list of vswitch ports.  The list is structured
+        as dictionary where the key is a port uuid and the value is the port
+        object.
+        """
+        try:
+            ports = collections.OrderedDict()
+            port_list = sorted(self.api.get_port_list(), key=port_sort_key)
+            for port in port_list:
+                ports[port['uuid']] = port
+            return ports
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query port list, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_virtual_port_list(self):
+        """
+        Retrieve the current list of virtual ports.  All physical ports are
+        excluded from the list.  The list is structured as dictionary where
+        the key is a port uuid and the value is the port object.
+        """
+        ports = self.get_port_list()
+        return collections.OrderedDict(
+            [(uuid, port) for uuid, port in six.iteritems(ports)
+             if getattr(port, 'neutron', False)])
+
+    def get_virtual_port_count(self):
+        """
+        Query the number of virtual ports are provisioned in the vswitch.  All
+        physical ports are excluded from the count.
+        """
+        return len(self.get_virtual_port_list())
+
+    def get_physical_port_list(self):
+        """
+        Retrieve the current list of physical ports.  All virtual ports are
+        excluded from the list.  The list is structured as dictionary where
+        the key is a port uuid and the value is the port object.
+        """
+        ports = self.get_port_list()
+        return collections.OrderedDict(
+            [(uuid, port) for uuid, port in six.iteritems(ports)
+             if port['type'] == avs_constants.VSWITCH_PHYSICAL_PORT])
+
+    def get_interface_list(self):
+        """
+        Retrieve the current list of logical interfaces.
+        The list is structured as dictionary where the key is an interface
+        uuid and the value is the interface object.  The interface objects are
+        augmented with a vlan list and/or member list depending on whether the
+        interface has upper vlans or lower AE members.
+        """
+        try:
+            interfaces = collections.OrderedDict()
+            tmp = sorted(self.api.get_interface_list(), key=interface_sort_key)
+            for iface in tmp:
+                interfaces[iface['uuid']] = iface
+                if iface['type'] == avs_constants.VSWITCH_VLAN_INTERFACE:
+                    lower_iface = interfaces[iface['lower-uuid']]
+                    vlans = getattr(lower_iface, 'vlans', [])
+                    vlans.append(iface['uuid'])
+                    setattr(lower_iface, 'vlans', vlans)
+                elif iface['type'] == avs_constants.VSWITCH_ETHERNET_INTERFACE:
+                    if 'upper-uuid' in iface:
+                        upper_iface = interfaces[iface['upper-uuid']]
+                        members = getattr(upper_iface, 'members', [])
+                        members.append(iface['uuid'])
+                        setattr(upper_iface, 'members', members)
+            return interfaces
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query interface list, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_lacp_interface_list(self):
+        """
+        Retrieve the current list of LACP enabled AE logical interfaces as
+        a tuple of LACP enabled (lower) interfaces and LACP enabled (upper)
+        AE interfaces.
+        The lists are structured as a tuple of two interfaces dictionaries,
+        where the key is an interface uuid and the value is the interface
+        object.
+        """
+        try:
+            interfaces = {}
+            ae_interfaces = {}
+            for interface in self.api.get_lacp_interface_list():
+                interfaces[interface['uuid']] = interface
+                ae_interfaces[interface['upper-uuid']] = \
+                    interface['upper-uuid']
+            return (interfaces, ae_interfaces)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query LACP interface list, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_router_interface_list(self, interfaces=None):
+        if interfaces is None:
+            interfaces = self.get_interface_list()
+        return collections.OrderedDict(
+            [(uuid, interface) for uuid, interface in six.iteritems(interfaces)
+             if interface['type'] == avs_constants.VSWITCH_ROUTER_INTERFACE])
+
+    def get_engine_stats(self):
+        """
+        Retrieve the current statistics for all engines.
+        """
+        try:
+            return self.api.get_engine_list_stats()
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query engine stats, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_port_stats(self):
+        """
+        Retrieve the current statistics for all ports.
+        """
+        try:
+            return self.api.get_port_list_stats()
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query port stats, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_interface_stats(self):
+        """
+        Retrieve the current statistics for all interfaces.
+        """
+        try:
+            return self.api.get_interface_list_stats()
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query interface stats, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_network_uuid(self, network_uuid, vlan_id=None):
+        """
+        Generate a unique network UUID based on the current network and
+        optional VLAN ID
+        """
+        if vlan_id:
+            namespace = uuid.UUID(network_uuid)
+            return str(uuid.uuid5(namespace, "vlan" + str(vlan_id)))
+        else:
+            return network_uuid
+
+    def get_interface_uuid(self, lower_uuid, vlan_id=None):
+        """
+        Generate a unique interface UUID based on the lower interface UUID
+        and vlan_id
+        """
+        if vlan_id:
+            namespace = uuid.UUID(lower_uuid)
+            return str(uuid.uuid5(namespace, "vlan" + str(vlan_id)))
+        else:
+            return lower_uuid
+
+    def get_vxlan_interface_uuid(self, lower_uuid, vxlan_id):
+        """
+        Generate a unique VXLAN interface UUID based on the lower interface
+        UUID and vxlan_id
+        """
+        return str(uuid.uuid5(uuid.UUID(lower_uuid), "vxlan" + str(vxlan_id)))
+
+    def get_physical_interface_uuid(self, physical_network):
+        """
+        Retrieve the uuid value of the physical interface that implements the
+        provider network named in physical_network.
+        """
+        value = self.interface_mappings.get(physical_network)
+        if not value:
+            msg = "No interface mapping for {}".format(physical_network)
+            raise VSwitchManagerError(msg)
+        return value
+
+    def get_provider_interface_uuid(self, lower_uuid, network_type,
+                                    segmentation_id=None):
+        """
+        Generate a unique provider interface UUID.  This needs to be
+        predictable and repeatible so we derive it from the lower uuid and the
+        provider interface details.
+        """
+        if network_type == 'flat':
+            return lower_uuid
+        else:
+            suffix = "%s-%s" % (str(network_type), str(segmentation_id or 0))
+            return str(uuid.uuid5(uuid.UUID(lower_uuid), suffix))
+
+    def update_port_filters(self, port_uuid, rules):
+        """
+        Update the rule filters for the supplied port.
+        """
+        LOG.debug("Updating port filters {} {}".format(port_uuid, rules))
+
+        try:
+            bindings = self.api.get_filter_bindings(port_uuid)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to retrieve port {} filter bindings, {}".format(
+                    port_uuid, e))
+            raise VSwitchManagerError(msg)
+
+        rule_lookup = {r['uuid']: r for r in rules}
+
+        new_rules = set([r['uuid'] for r in rules])
+        old_rules = set(bindings['rules'])
+
+        removed_rules = old_rules - new_rules
+        added_rules = new_rules - old_rules
+
+        for rule_uuid in added_rules:
+            rule = rule_lookup[rule_uuid]
+
+            try:
+                self.api.add_filter_rule(rule)
+                self.api.add_filter_binding(rule, port_uuid)
+            except exceptions.VSwitchError as e:
+                msg = ("Failed to add port {} filter {}, {}".format(
+                        port_uuid, rule_uuid, e))
+                raise VSwitchManagerError(msg)
+
+        for rule_uuid in removed_rules:
+            rule = {'uuid': rule_uuid}
+
+            try:
+                self.api.delete_filter_binding(rule, port_uuid)
+                self.api.delete_filter_rule(rule)
+            except exceptions.VSwitchFilterForbiddenError:
+                LOG.debug("Filter rule {} still in-use".format(rule_uuid))
+            except exceptions.VSwitchError as e:
+                msg = ("Failed to remove port {} filter {}, {}".format(
+                        port_uuid, rule_uuid, e))
+                raise VSwitchManagerError(msg)
+
+    def remove_port_filters(self, port_uuid, rules):
+        """
+        Remove the rule filters for the supplied port.
+        """
+        LOG.debug("Removing port filters {} {}".format(port_uuid, rules))
+
+        for rule in rules:
+
+            try:
+                self.api.delete_filter_binding(rule, port_uuid)
+            except exceptions.VSwitchFilterNotFoundError:
+                LOG.debug(("Port {} filter binding {} not found".format(
+                            port_uuid, rule['uuid'])))
+            except exceptions.VSwitchError as e:
+                msg = ("Failed to remove port {} filter binding {}, {}".format(
+                        port_uuid, rule['uuid'], e))
+                raise VSwitchManagerError(msg)
+
+            try:
+                self.api.delete_filter_rule(rule)
+            except exceptions.VSwitchFilterNotFoundError:
+                LOG.debug("Filter rule {} not found".format(rule['uuid']))
+            except exceptions.VSwitchFilterForbiddenError:
+                LOG.debug("Filter rule {} still in-use".format(rule['uuid']))
+            except exceptions.VSwitchError as e:
+                msg = ("Failed to remove port {} filter rule {}, {}".format(
+                        port_uuid, rule['uuid'], e))
+                raise VSwitchManagerError(msg)
+
+    def add_address(self, address, prefixlen, interface_uuid, **kwargs):
+        """
+        Create a new IP address on the supplied interface.
+        """
+        LOG.debug("Adding IP address {}/{} on {}".format(
+            address, prefixlen, interface_uuid))
+
+        # Create new address
+        address = {
+            'interface-uuid': interface_uuid,
+            'address': str(address),
+            'prefix-length': prefixlen,
+        }
+        for arg in kwargs:
+            address[arg] = kwargs[arg]
+        try:
+            self.api.add_address(address)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add IP address {}, {}".format(address, e))
+
+    def delete_address(self, address, prefixlen, interface_uuid):
+        """
+        Create an existing IP address from the supplied interface.
+        """
+        LOG.debug("Removing IP address {}/{} on {}".format(
+            address, prefixlen, interface_uuid))
+
+        # Create new address
+        address = {
+            'interface-uuid': interface_uuid,
+            'address': str(address),
+            'prefix-length': prefixlen,
+        }
+        try:
+            self.api.delete_address(address)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to delete IP address {}, {}".format(address, e))
+
+    def get_address_list(self, family=None, interface_uuid=None):
+        """
+        Retrieve the current list of IP addresses.  The list is structured as
+        dictionary where the key is an IP address and the value is the
+        address object.
+
+        """
+        try:
+            addresses = {}
+            for address in self.api.get_address_list(
+                    family=family, interface_uuid=interface_uuid):
+                addresses[address['address']] = address
+            return addresses
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query address list, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def add_route(self, router_uuid, prefix, prefixlen,
+                  interface_uuid=None, gateway=None, replace=False):
+        """
+        Create a new route to vswitch.
+        """
+        LOG.debug("Adding route {}/{} to {} {} from {}".format(
+            prefix, prefixlen, interface_uuid, gateway, router_uuid))
+
+        nexthop = {}
+        if interface_uuid:
+            nexthop['interface-uuid'] = interface_uuid
+        if gateway:
+            nexthop['gateway'] = str(gateway)
+
+        route = {
+            'router-uuid': router_uuid,
+            'prefix': str(prefix),
+            'prefix-length': prefixlen,
+            'nexthops': [nexthop],
+        }
+
+        try:
+            if replace:
+                self.api.replace_route(route)
+            else:
+                self.api.add_route(route)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add route {}, {}".format(route, e))
+
+    def delete_route(self, router_uuid, prefix, prefixlen):
+        """
+        Create an existing route from vswitch.
+        """
+        LOG.debug("Removing route {}/{} from {}".format(
+            prefix, prefixlen, router_uuid))
+
+        route = {
+            'router-uuid': router_uuid,
+            'prefix': str(prefix),
+            'prefix-length': prefixlen,
+        }
+
+        try:
+            self.api.delete_route(route)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to remove route {}, {}".format(route, e))
+
+    def add_neighbour(self, interface_uuid, ip_address, mac_address):
+        """
+        Add a static neighbour entry to an interface
+        """
+        LOG.debug("Adding neighbour {} for {} on {}".format(
+                mac_address, ip_address, interface_uuid))
+        neighbour = {
+            'mac-address': mac_address,
+            'address': ip_address,
+            'interface-uuid': interface_uuid}
+        try:
+            self.api.add_neighbour(neighbour)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add neighbour {}, {}".format(neighbour, e))
+
+    def delete_neighbour(self, interface_uuid, ip_address):
+        """
+        Remove a static neighbour entry from an interface
+        """
+        LOG.debug("Removing neighbour for {} from {}".format(
+                ip_address, interface_uuid))
+        neighbour = {
+            'address': ip_address,
+            'interface-uuid': interface_uuid}
+        try:
+            self.api.delete_neighbour(neighbour)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to add delete {}, {}".format(neighbour, e))
+
+    def get_neighbours(self, interface_uuid):
+        """
+        Retrieve the list of neighbours for a given interface.
+        """
+        LOG.debug("Querying neighbours for {}".format(interface_uuid))
+        try:
+            return self.api.get_neighbours(interface_uuid)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to query neighbours on {}, {}".format(
+                    interface_uuid, e))
+
+    def get_router_name(self, router_uuid):
+        """
+        The plugin does not send us the router name therefore we build one
+        based on the router uuid.
+        """
+        return "rtr-" + router_uuid[:8]
+
+    def get_fip_router_name(self, network_uuid):
+        """
+        The agent automatically creates a shared router context to represent
+        what upstream openstack refers to as the FIP namespace.  There is no
+        name assigned by the plugin so we generate one automatically based on
+        the external network uuid.
+        """
+        return "fip-" + network_uuid[:8]
+
+    def get_router_list(self):
+        """
+        Retrieve the current list of neutron managed virtual routers.
+        The list is structured as dictionary where the key is a router
+        uuid and the value is the router object.
+        """
+        try:
+            routers = {}
+            for router in self.api.get_router_list():
+                if getattr(router, 'neutron', False):
+                    routers[router['uuid']] = router
+            return routers
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query router list, {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def get_router(self, uuid):
+        """
+        Obtain an router object by uuid.
+        """
+        try:
+            return self.api.get_router(uuid)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to query router {}, {}".format(uuid, e))
+
+    def get_router_interfaces(self, uuid):
+        try:
+            interfaces = {}
+            for interface in self.api.get_router_interfaces(uuid):
+                interfaces[interface['uuid']] = interface
+            return interfaces
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query router interfaces for {}, {}".
+                   format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def get_router_routes(self, uuid):
+        try:
+            return self.api.get_router_routes(uuid)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query router routes for {}, {}".format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def get_router_fip_addresses(self, uuid):
+        try:
+            for addr in self.api.get_address_list():
+                if (getattr(addr, 'router-uuid', None) == uuid and
+                        getattr(addr, 'floating-ip', False)):
+                    yield addr
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query address list for {}, {}".format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def add_router(self, uuid, name,
+                   neutron_managed=False, snat_enabled=False):
+        """
+        Create a new virtual router to vswitch.
+        """
+        LOG.debug("Adding router {}".format(uuid))
+        # Determine if the router already exists
+        try:
+            router = self.get_router(uuid)
+        except VSwitchManagerError:
+            router = None
+
+        if not router:
+            # Create new router
+            router = {
+                'uuid': uuid,
+                'name': name,
+                'neutron': neutron_managed,
+                'snat-enabled': snat_enabled
+            }
+            try:
+                self.api.add_router(router)
+            except exceptions.VSwitchError as e:
+                raise VSwitchManagerError(
+                    "Failed to add router {}, {}".format(router, e))
+
+    def update_router(self, uuid, snat_enabled=False):
+        """
+        Update an existing virtual router to vswitch.
+        """
+        LOG.debug("Update router {}".format(uuid))
+
+        router = {
+            'uuid': uuid,
+            'snat-enabled': snat_enabled
+        }
+        try:
+            self.api.update_router(router)
+        except exceptions.VSwitchError as e:
+            raise VSwitchManagerError(
+                "Failed to update router {}, {}".format(router, e))
+
+    def delete_router(self, uuid):
+        """
+        Delete an existing virtual router from vswitch.
+        """
+        LOG.debug("Deleting router {}".format(uuid))
+        try:
+            # Delete the router
+            router = {'uuid': uuid}
+            self.api.delete_router(router)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to delete router {}, {}".format(uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def attach_router_interface(self, router_uuid, interface_uuid):
+        """
+        Attach the supplied interface to the router
+        :param router_uuid: The UUID of the router
+        :param interface_uuid: The UUID of the interface to attach
+        :return: None
+        """
+        LOG.debug("Attach interface {} from router {}".format(
+            interface_uuid, router_uuid))
+
+        router = {'uuid': router_uuid,
+                  'interface-uuid': interface_uuid}
+        try:
+            self.api.router_attach_interface(router)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to attach router interface {}, {}".format(
+                router, e))
+            raise VSwitchManagerError(msg)
+
+    def detach_router_interface(self, router_uuid, interface_uuid):
+        """
+        Detach the supplied interface from the router
+        :param router_uuid: The UUID of the router
+        :param interface_uuid: The UUID of the interface to detach
+        :return: None
+        """
+        LOG.debug("Detach interface {} from router {}".format(
+            interface_uuid, router_uuid))
+
+        router = {'uuid': router_uuid,
+                  'interface-uuid': interface_uuid}
+        try:
+            self.api.router_detach_interface(router)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to detach router interface {}, {}".format(
+                router, e))
+            raise VSwitchManagerError(msg)
+
+    def get_dvr_host_macs(self):
+        """
+        Query the current set of peer DVR MAC addresses that are known to the
+        vswitch.
+        """
+        LOG.debug("Query DVR host MAC addresses")
+        try:
+            return self.api.get_dvr_host_macs()
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query DVR host MAC addresses {}".format(e))
+            raise VSwitchManagerError(msg)
+
+    def update_dvr_host_macs(self, host_macs):
+        """
+        Update the current set of peer DVR MAC addresses that are known to the
+        vswitch.
+        """
+        LOG.debug("Update DVR host MAC addresses: {}".format(host_macs))
+        try:
+            return self.api.update_dvr_host_macs(host_macs)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to update DVR host MAC addresses {}: {}".format(
+                    host_macs, e))
+            raise VSwitchManagerError(msg)
+
+    def _convert_protocol_to_avs(self, protocol):
+        protocol = protocol.lower()
+        if protocol in AVS_NAT_PROTOCOLS:
+            return AVS_NAT_PROTOCOLS[protocol]
+        LOG.warning("No AVS NAT protocol conversion for {}; "
+                    "trying original value".format(protocol))
+        return protocol
+
+    def add_snat_entry(self, interface_uuid, src_address,
+                       src_port, nat_port, protocol, **kwargs):
+        """
+        Add an IPv4 static SNAT entry.
+        """
+        try:
+            snat = {'interface-uuid': interface_uuid,
+                    'src-address': src_address,
+                    'src-proto-key': src_port,
+                    'nat-proto-key': nat_port,
+                    'protocol': self._convert_protocol_to_avs(protocol)}
+            return self.api.add_snat_entry(snat)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to add static SNAT entry {}: {}".format(snat, e))
+            raise VSwitchManagerError(msg)
+
+    def delete_snat_entry(self, interface_uuid, src_address,
+                          src_port, protocol):
+        """
+        Delete an IPv4 static SNAT entry.
+        """
+        try:
+            return self.api.delete_snat_entry(interface_uuid,
+                                              src_address,
+                                              src_port,
+                                              protocol)
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to delete static SNAT entry {}:{} {} on {}: {}".
+                   format(src_address, src_port, protocol, interface_uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def get_snat_entries(self, interface_uuid, static=True):
+        """
+        Get the list of IPv4 SNAT entries for an interface.
+        """
+        try:
+            type_value = 'static' if static else 'dynamic'
+            for addr in self.api.get_snat_list():
+                if (static is not None and (addr['type'] != type_value)):
+                    continue
+                if addr['interface-uuid'] == interface_uuid:
+                    yield addr
+        except exceptions.VSwitchError as e:
+            msg = ("Failed to query SNAT list for {}, {}".
+                   format(interface_uuid, e))
+            raise VSwitchManagerError(msg)
+
+    def _send_ping_request(self, body):
+        for i in range(3):
+            try:
+                response = self.api.send_ping_request(body)
+                ping_id = response['identifier']
+            except Exception as e:
+                LOG.warning("send_ping failed with error {}".format(e))
+                time.sleep(1)
+                continue
+            return ping_id
+        return None
+
+    def _get_ping_response(self, ping_id):
+        check_interval = avs_constants.VSWITCH_PING_RESPONSE_CHECK_INTERVAL
+        check_multiplier = avs_constants.VSWITCH_PING_RESPONSE_CHECK_MULTIPLIER
+        check_count = avs_constants.VSWITCH_PING_RESPONSE_CHECK_COUNT
+        for i in range(check_count):
+            progress = self.api.get_ping_response(ping_id)
+            progress = sorted(progress, key=lambda x: x['index'])
+            for entry in progress or []:
+                if entry['type'] == 'error':
+                    return False
+                elif entry['type'] == 'summary':
+                    return True
+            time.sleep(check_interval)
+            check_interval = check_interval * check_multiplier
+        progress = self.api.get_ping(ping_id)
+        progress = sorted(progress, key=lambda x: x['index'])
+        for entry in progress or []:
+            if entry['type'] == 'error':
+                return False
+            elif entry['type'] == 'summary':
+                return True
+        return False
+
+    def ping(self, ip_address, interface_uuid, length=64, count=1):
+        """
+        Use vswitch API to ping given address from specified interface.
+        """
+        body = {'address': ip_address,
+                'interface': interface_uuid,
+                'count': count,
+                'length': length}
+        ping_id = self._send_ping_request(body)
+        if ping_id:
+            return self._get_ping_response(ping_id)
+        return False
+
+    def get_openflow_bridge_uuid(self, network_name):
+        """
+        Calculate the uuid value that AVS will be using for a given openflow
+        bridge name.
+        """
+        suffix = "bridge-%s" % network_name
+        return str(uuid.uuid5(uuid.UUID(tsconfig.host_uuid), suffix))
diff --git a/neutron/agent/vswitch/vif_api.py b/neutron/agent/vswitch/vif_api.py
new file mode 100644
index 0000000..4d61e87
--- /dev/null
+++ b/neutron/agent/vswitch/vif_api.py
@@ -0,0 +1,99 @@
+#    Copyright 2011 OpenStack Foundation
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2014 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+import socket
+
+import eventlet
+from oslo_serialization import jsonutils
+
+VIF_BUFFER_LENGTH = 1024
+VIF_UDP_ADDRESS = '127.0.0.1'
+VIF_UDP_PORT = 9001
+
+
+class VifAgentListenerMixin(object):
+    """Abstract representation of the API that must be implemented by the
+    listener agent.
+    """
+    def vif_created(self, vif_id):
+        pass
+
+    def vif_deleted(self, vif_id):
+        pass
+
+    def vif_error_handler(self, exception):
+        pass
+
+
+class VifAgentListener(object):
+    """Implements the server side of the VIF notification API."""
+    def __init__(self, agent, **kwargs):
+        self.address = kwargs.get('address', VIF_UDP_ADDRESS)
+        self.port = kwargs.get('port', VIF_UDP_PORT)
+        self.agent = agent
+        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        self.sock.bind((self.address, self.port))
+        self.running = True
+        self.thread = eventlet.greenthread.spawn(
+            self._vif_message_handler, self.agent, self.sock)
+
+    def _vif_message_handler(self, agent, sock):
+        """Implements the UDP receive function that relays valid messages
+        to the agent object.
+        """
+        while self.running:
+            try:
+                data, addr = sock.recvfrom(VIF_BUFFER_LENGTH)
+                msg = jsonutils.loads(data)
+                for key in msg.keys():
+                    if 'vif_created' in msg:
+                        body = msg['vif_created']
+                        agent.vif_created(body['uuid'])
+                    if 'vif_deleted' in msg:
+                        body = msg['vif_deleted']
+                        agent.vif_created(body['uuid'])
+            except Exception as e:
+                agent.vif_error_handler(e)
+
+    def wait(self):
+        """Waits for the listener thread to terminate voluntarily"""
+        self.running = False
+        return self.thread.wait()
+
+    def kill(self):
+        """Kills the listener thread"""
+        return self.thread.kill()
+
+
+class VifAgentNotifier(object):
+    """Implements the client side of the VIF notification API."""
+    def __init__(self, **kwargs):
+        self.address = kwargs.get('address', VIF_UDP_ADDRESS)
+        self.port = kwargs.get('port', VIF_UDP_PORT)
+        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+
+    def vif_created(self, vif_id):
+        msg = {'vif_created': {'uuid': vif_id}}
+        self.sock.sendto(jsonutils.dumps(msg), (self.address, self.port))
+
+    def vif_deleted(self, vif_id):
+        msg = {'vif_deleted': {'uuid': vif_id}}
+        self.sock.sendto(jsonutils.dumps(msg), (self.address, self.port))
diff --git a/neutron/db/l3_dvr_db.py b/neutron/db/l3_dvr_db.py
index 71ceedb..6e9db9e 100644
--- a/neutron/db/l3_dvr_db.py
+++ b/neutron/db/l3_dvr_db.py
@@ -842,6 +842,8 @@ class _DVRAgentInterfaceMixin(object):
                   {'gw': agent_gw_port,
                    'dest_host': host})
 
+    @n_utils.synchronized('create_fip_agent_gw_port_if_not_exists',
+                          external=True)
     def create_fip_agent_gw_port_if_not_exists(
         self, context, network_id, host):
         """Function to return the FIP Agent GW port.
diff --git a/neutron/extensions/wrs_binding.py b/neutron/extensions/wrs_binding.py
index 2794f9c..9190802 100644
--- a/neutron/extensions/wrs_binding.py
+++ b/neutron/extensions/wrs_binding.py
@@ -34,6 +34,7 @@ MTU = 'wrs-binding:mtu'
 VIF_MODEL = 'wrs-binding:vif_model'
 
 VIF_MODEL_DEFAULT = 'default'
+VIF_MODEL_VIRTIO = 'virtio'
 VIF_MODEL_PCI_PASSTHROUGH = 'pci-passthrough'
 
 # The mac_filtering attribute describes whether the MAC filtering was enabled
@@ -42,6 +43,10 @@ MAC_FILTERING = 'wrs-binding:mac_filtering'
 
 VIF_TYPE_AVS = 'avs'
 
+# - vhostuser_enabled: Boolean value used to determine whether vhostuser can
+#                      be enabled for this binding
+VHOST_USER_ENABLED = 'vhostuser_enabled'
+
 EXTENDED_ATTRIBUTES_2_0 = {
     'ports': {
         VIF_MODEL: {'allow_post': True, 'allow_put': True,
diff --git a/neutron/opts.py b/neutron/opts.py
index a58771b..65edc2a 100644
--- a/neutron/opts.py
+++ b/neutron/opts.py
@@ -59,6 +59,7 @@ import neutron.extensions.l3
 import neutron.extensions.securitygroup
 import neutron.plugins.ml2.config
 import neutron.plugins.ml2.drivers.mech_sriov.agent.common.config
+import neutron.plugins.wrs.agent.avs.agent
 import neutron.setting
 import neutron.wsgi
 
@@ -311,3 +312,23 @@ def list_settings_opts():
         ('settings',
          neutron.setting.setting_opts)
     ]
+
+
+def list_pnet_connectivity_opts():
+    return [
+        ('pnet_connectivity',
+         neutron.db.providernet_db.PNET_CONNECTIVITY_OPTS)
+    ]
+
+
+def list_avs_agent_opts():
+    return [
+        ('AVS',
+         neutron.plugins.wrs.agent.avs.agent.avs_opts),
+        ('AGENT',
+         neutron.plugins.wrs.agent.avs.agent.agent_opts),
+        ('VXLAN',
+         neutron.plugins.wrs.agent.avs.agent.vxlan_opts),
+        ('SECURITYGROUP',
+         neutron.conf.agent.securitygroups_rpc.security_group_opts)
+    ]
diff --git a/neutron/plugins/wrs/agent/__init__.py b/neutron/plugins/wrs/agent/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/plugins/wrs/agent/avr/__init__.py b/neutron/plugins/wrs/agent/avr/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/plugins/wrs/agent/avr/agent.py b/neutron/plugins/wrs/agent/avr/agent.py
new file mode 100644
index 0000000..8f8ddf1
--- /dev/null
+++ b/neutron/plugins/wrs/agent/avr/agent.py
@@ -0,0 +1,1389 @@
+# Copyright 2015 OpenStack Foundation
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+from random import randint
+import sys
+
+import eventlet
+eventlet.monkey_patch()
+
+import netaddr
+import six
+
+from neutron_lib import constants
+from neutron_lib import context
+from neutron_lib.utils import helpers
+from oslo_config import cfg
+from oslo_log import log as logging
+import oslo_messaging
+from oslo_service import loopingcall
+from oslo_service import service
+from oslo_utils import importutils
+
+from neutron._i18n import _
+from neutron.agent.l3 import agent as l3_agent
+from neutron.agent.linux import external_process
+from neutron.agent.linux import interface
+from neutron.agent.linux import ip_lib
+from neutron.agent import rpc
+from neutron.agent.vswitch import api as vswitch_api
+from neutron.agent.vswitch import constants as vswitch_constants
+from neutron.agent.vswitch import manager as vswitch_manager
+from neutron.common import config as common_config
+from neutron.common import constants as n_const
+from neutron.common import topics
+from neutron.common import utils
+from neutron.conf.agent import common as config
+from neutron.extensions import wrs_binding
+from neutron import manager
+from neutron import service as neutron_service
+
+
+LOG = logging.getLogger(__name__)
+
+ROUTER_NS_PREFIX = 'avr-'
+METADATA_DEV_PREFIX = 'md-'
+METADATA_DEFAULT_PREFIX = 16
+METADATA_DEFAULT_IP = '169.254.169.254'
+METADATA_ROUTER_IP = '169.254.169.253'
+METADATA_DEFAULT_CIDR = '%s/%d' % (METADATA_DEFAULT_IP,
+                                   METADATA_DEFAULT_PREFIX)
+
+ROUTER_OWNERS = [constants.DEVICE_OWNER_ROUTER_INTF,
+                 constants.DEVICE_OWNER_DVR_INTERFACE]
+
+# Event Queue Priorities (lower value is higher priority)
+RPC_EVENT_PRIORITY = 0
+ROUTER_SYNC_PRIORITY = 1
+
+# Event Queue actions
+UPDATE_EVENT = 1
+DELETE_EVENT = 2
+SYNC_EVENT = 3
+
+ROUTER_MAX_QUEUE_SIZE = 64
+
+# Floating IP addresses are added with a fixed prefix len
+FLOATING_IP_PREFIX_LEN = 32
+
+
+def get_staggered_timeout(value, stagger=None):
+    """
+    Return an integer of value +/- stagger.
+    """
+    if not stagger:
+        return value
+    stagger = min(value / 2, stagger)
+    return randint(value - stagger, value + stagger)
+
+
+class EventMessage(object):
+    """
+    Represents a queued RPC event or periodic task notification.
+    """
+    def __init__(self, action, priority, router_ids=None):
+        self.action = action
+        self.priority = priority
+        self.router_ids = router_ids
+
+    def __repr__(self):
+        return "EventMessage(action={}, priority={} ids={})".format(
+            self.action, self.priority, self.router_ids)
+
+    def merge(self, other):
+        """
+        Combines the router_ids list from both objects
+        """
+        if not self.router_ids:
+            self.router_ids = other.router_ids
+        if not other.router_ids:
+            return
+        self.router_ids = list(set(self.router_ids) | set(other.router_ids))
+
+    def __lt__(self, other):
+        """
+        Exposes ordering rules for the priority queue class.
+        """
+        return self.priority < other.priority
+
+
+class AVRAgentManager(manager.Manager):
+    """Manager for AVR (L3) Agent"""
+
+    OPTS = [
+        cfg.IntOpt('resync_interval', default=300,
+                   help=_("Interval to periodically resync.")),
+        cfg.BoolOpt('enable_metadata_proxy', default=True,
+                    help=_("Allow running metadata proxy.")),
+        cfg.StrOpt('metadata_proxy_socket',
+                   default='$state_path/metadata_proxy',
+                   help=_('Location of Metadata Proxy UNIX domain '
+                          'socket')),
+        cfg.IntOpt('metadata_port',
+                   default=80,
+                   help=_("TCP Port used by Neutron metadata namespace "
+                          "proxy.")),
+        cfg.StrOpt('metadata_mac_address',
+                   default="fa:16:3d:00:00:01",
+                   help=_("MAC Address to be used by metadata namespace "
+                          "proxy interface.")),
+        cfg.BoolOpt('router_delete_namespaces', default=False,
+                    help=_("Delete namespace after removing a router.")),
+        cfg.IntOpt('snat_interface_weight', default=250,
+                   help=_("Weight assigned to SNAT router interfaces.")),
+    ]
+
+    target = oslo_messaging.Target(version='1.2')
+
+    def __init__(self, host):
+        super(AVRAgentManager, self).__init__(host=host)
+        self.conf = cfg.CONF
+        self.root_helper = config.get_root_helper(self.conf)
+        self.routers = {}
+        self.agent_gateway_ports = {}
+        self.agent_state = {
+            'binary': 'neutron-avr-agent',
+            'host': host,
+            'availability_zone': cfg.CONF.AGENT.availability_zone,
+            'topic': topics.L3_AGENT,
+            'start_flag': True,
+            'agent_type': constants.AGENT_TYPE_L3,
+            'configurations': {
+                'agent_mode': constants.L3_AGENT_MODE_DVR_SNAT,
+                'interface_driver': self.conf.interface_driver}}
+
+        self.vswitch_mgr = vswitch_manager.VSwitchManager(
+            vswitch_api.VSwitchManagementAPI())
+
+        try:
+            self.vif_driver = importutils.import_object(
+                self.conf.interface_driver,
+                self.conf
+            )
+        except Exception:
+            msg = ("Error importing interface driver "
+                   "'%s'") % self.conf.interface_driver
+            LOG.error(msg)
+            raise SystemExit(1)
+
+        self.context = context.get_admin_context_without_session()
+        self.plugin_rpc = l3_agent.L3PluginApi(topics.L3PLUGIN, host)
+        self.queue = eventlet.queue.LightQueue(maxsize=ROUTER_MAX_QUEUE_SIZE)
+
+        self.use_call = True
+        self.state_rpc = rpc.PluginReportStateAPI(topics.PLUGIN)
+        report_interval = self.conf.AGENT.report_interval
+        if report_interval:
+            self.heartbeat = loopingcall.FixedIntervalLoopingCall(
+                self._report_state)
+            self.heartbeat.start(interval=report_interval)
+        resync_interval = get_staggered_timeout(self.conf.resync_interval, 30)
+        if resync_interval:
+            self.resync_task = loopingcall.FixedIntervalLoopingCall(
+                self._sync_routers_task)
+            self.resync_task.start(interval=resync_interval)
+
+    def after_start(self):
+        eventlet.spawn_n(self._event_handler)
+        LOG.info("AVR agent started")
+
+    def after_stop(self):
+        for router_id in self.routers:
+            self._destroy_metadata_proxy({'id': router_id})
+        LOG.info("AVR agent stopped")
+
+    def agent_updated(self, context, payload):
+        """Handle the agent_updated notification event."""
+        LOG.info("agent_updated by server side %s!", payload)
+        self._event_notify(SYNC_EVENT, ROUTER_SYNC_PRIORITY)
+
+    def routers_updated(self, context, routers):
+        """Deal with routers modification and creation RPC message."""
+        LOG.info("routers_updated by server side %s!", routers)
+        self._event_notify(UPDATE_EVENT, RPC_EVENT_PRIORITY, routers)
+
+    def router_deleted(self, context, router_id):
+        """Deal with routers modification and creation RPC message."""
+        LOG.info("router_deleted by server side %s!", router_id)
+        self._event_notify(DELETE_EVENT, RPC_EVENT_PRIORITY, [router_id])
+
+    def add_arp_entry(self, context, payload):
+        """Add static ARP entry into router context. Called from RPC."""
+        router_id = payload['router_id']
+        if router_id in self.routers:
+            LOG.info("Add static ARP entry: {}".format(payload))
+            self._event_notify(UPDATE_EVENT, RPC_EVENT_PRIORITY, [router_id])
+        else:
+            LOG.debug("Ignored broadcast ARP entry update: {}".format(payload))
+
+    def del_arp_entry(self, context, payload):
+        """Delete static ARP entry from router context. Called from RPC."""
+        router_id = payload['router_id']
+        if router_id in self.routers:
+            LOG.info("Delete static ARP entry: {}".format(payload))
+            self._event_notify(UPDATE_EVENT, RPC_EVENT_PRIORITY, [router_id])
+        else:
+            LOG.debug("Ignored broadcast ARP entry delete: {}".format(payload))
+
+    def fipnamespace_delete_on_ext_net(self, context, ext_net_id):
+        """Delete fip namespace after external network removed."""
+        LOG.info("Delete FIP namespace for net: {}".format(ext_net_id))
+        # We do not have FIP namespaces just log for now.
+
+    def router_added_to_agent(self, context, payload):
+        LOG.info("Router added to agent: {}".format(payload))
+        self._event_notify(UPDATE_EVENT, RPC_EVENT_PRIORITY, payload)
+
+    def router_removed_from_agent(self, context, payload):
+        LOG.info("Router removed from agent: {}".format(payload))
+        router_id = payload['router_id']
+        self.router_deleted(context, router_id)
+
+    def _drain_event_queue(self):
+        events = []
+        sync_event = None
+        # Wait until a message arrives.  No need to timeout because the
+        # sync_routers periodic task will be sending messages at regular
+        # intervals to wake us up.
+        events.append(self.queue.get())
+        # Then drain the queue of all pending events coalescing all
+        # consecutive events of the same type in to a single event
+        while True:
+            try:
+                event = self.queue.get_nowait()
+                last = events[-1]
+                if last.action == event.action:
+                    event.merge(last)
+                    events[-1] = event
+                elif event.action == SYNC_EVENT:
+                    # process sync events last
+                    sync_event = event
+                else:
+                    events.append(event)
+            except eventlet.queue.Empty:
+                break
+        return events + ([] if not sync_event else [sync_event])
+
+    @utils.exception_logger()
+    def _event_handler(self):
+        while True:
+            events = self._drain_event_queue()
+            for event in events:
+                if event.action == DELETE_EVENT:
+                    self._remove_routers(event.router_ids)
+                else:
+                    self._sync_routers(router_ids=event.router_ids)
+
+                # run full audit on every periodic sync
+                if event.action == SYNC_EVENT:
+                    self._audit_routers()
+
+    def _event_notify(self, action, priority, router_ids=None):
+        try:
+            event = EventMessage(action, priority, router_ids=router_ids)
+            # wake up router event processing thread
+            self.queue.put_nowait(event)
+        except eventlet.queue.Full as e:
+            LOG.exception(e)
+
+    def _sync_routers_task(self):
+        self._event_notify(SYNC_EVENT, ROUTER_SYNC_PRIORITY)
+
+    def _report_state(self):
+        try:
+            configurations = self.agent_state['configurations']
+            configurations['routers'] = len(self.routers)
+            self.state_rpc.report_state(self.context, self.agent_state,
+                                        self.use_call)
+            self.agent_state.pop('start_flag', None)
+            self.use_call = False
+        except AttributeError:
+            # This means the server does not support report_state
+            LOG.warning("Neutron server does not support state report."
+                        " State report for this agent will be disabled.")
+            self.heartbeat.stop()
+            return
+        except Exception:
+            LOG.exception("Failed reporting state!")
+
+    def _is_gateway_owner(self, router):
+        if not router.get('distributed', False):
+            return True
+        gateway_host = router.get('gw_port_host', None)
+        if gateway_host and (gateway_host == self.host):
+            return True
+        return False
+
+    def _sanitize_router(self, router):
+        if not router.get('distributed', False):
+            return router
+        if not self._is_gateway_owner(router):
+            router.pop('gw_port', None)
+            router.pop('gw_port_host', None)
+        return router
+
+    def _remove_routers(self, router_ids=None):
+        for router_id in router_ids or []:
+            if router_id not in self.routers:
+                continue
+            self._remove_router(self.routers[router_id])
+            del self.routers[router_id]
+
+    def _sync_routers(self, router_ids=None):
+        """
+        Sync the current set of routers in AVS against the current set of
+        routers in the DB.  If a list of router id values is specified in the
+        router_ids argument then the sync audit is constrained to only that set
+        of routers.
+        """
+        LOG.debug("AVR syncing routers: router_ids={}".format(router_ids))
+        try:
+            # retrieve the latest list of routers keyed by id
+            routers = {router['id']: router for router in
+                       self.plugin_rpc.get_routers(self.context, router_ids)}
+            router_ids = set(router_ids or [])
+
+            # adjust routers to remove components not owned or assigned to
+            # this router.
+            for router_id, router in six.iteritems(routers):
+                routers[router_id] = self._sanitize_router(router)
+
+            current = set(routers)
+            existing = set(self.routers)
+            if router_ids:
+                existing &= router_ids
+
+            added = current - existing
+            removed = existing - current
+            updated = existing & current
+
+            for router_id in removed:
+                self._remove_router(self.routers[router_id])
+                del self.routers[router_id]
+
+            for router_id in added:
+                self._add_router(routers[router_id])
+
+            for router_id in updated:
+                self._update_router(routers[router_id])
+
+            # save current set of routers for next interval
+            self.routers.update(routers)
+
+        except Exception:
+            msg = "Failed to sync router information"
+            LOG.exception(msg)
+
+    def _audit_routers(self):
+        """
+        Audit the current set of routers in AVS against the current set of
+        routers maintained in the agent.
+        """
+        LOG.debug("AVR audit routers")
+        try:
+            local_routers = self.routers
+            remote_routers = self.vswitch_mgr.get_router_list()
+
+            local = set(local_routers)
+            remote = set(remote_routers)
+
+            missing = local - remote
+            orphaned = remote - local
+            audit = local & remote
+
+            for router_id in orphaned:
+                LOG.warning("AVR remove orphaned router {}".format(
+                    router_id))
+                self.vswitch_mgr.delete_router(router_id)
+
+            for router_id in missing:
+                LOG.warning("AVR add missing router {}".format(router_id))
+                self._add_router(local_routers[router_id])
+
+            for router_id in audit:
+                self._audit_router(local_routers[router_id],
+                                   remote_routers[router_id])
+        except Exception:
+            msg = "Failed to audit router information"
+            LOG.exception(msg)
+
+    def _add_router(self, router):
+        LOG.info("AVR add router: {}".format(router))
+        router_name = self.vswitch_mgr.get_router_name(router['id'])
+        snat_enabled = router.get('enable_snat', False)
+        self.vswitch_mgr.add_router(router['id'], router_name,
+                                    True, snat_enabled)
+        self._add_gateway_port(router)
+        self._add_internal_ports(router)
+        self._add_snat_ports(router)
+        self._add_fip_addresses(router)
+        self._add_dnat_rules(router)
+        self._add_routes(router)
+        self._spawn_metadata_proxy(router)
+
+    def _update_router(self, router):
+        LOG.debug("AVR update router: {}".format(router))
+
+        existing_router = self.routers.get(router['id'])
+        existing_snat = existing_router.get('enable_snat', False)
+        current_snat = router.get('enable_snat', False)
+        if existing_snat != current_snat:
+            self.vswitch_mgr.update_router(router['id'], current_snat)
+
+        self._update_gateway_port(router)
+        self._update_internal_ports(router)
+        self._update_snat_ports(router)
+        self._update_fip_addresses(router)
+        self._update_dnat_rules(router)
+        self._update_routes(router)
+
+    def _remove_router(self, router):
+        LOG.info("AVR remove router: {}".format(router))
+        self._delete_agent_gateway_port(router)
+        self.vswitch_mgr.delete_router(router['id'])
+        self._destroy_metadata_proxy(router)
+
+    def _audit_router(self, local_router, remote_router):
+        LOG.debug("AVR audit router: {}".format(local_router))
+
+        # Audit the router specific properties
+        router_id = local_router.get('id')
+        local_snat = local_router.get('enable_snat', False)
+        remote_snat = getattr(remote_router, 'snat-enabled', False)
+        if local_snat != remote_snat:
+            LOG.warning("AVR correct router SNAT state {} to {}".
+                        format(router_id, local_snat))
+            self.vswitch_mgr.update_router(router_id, local_snat)
+
+        self._audit_router_ports(local_router)
+        self._audit_fip_addresses(local_router)
+        self._audit_dnat_rules(local_router)
+        self._audit_routes(local_router)
+
+    def _audit_router_ports(self, router):
+        router_id = router.get('id')
+        router_interfaces = self.vswitch_mgr.get_router_interfaces(router_id)
+
+        self._audit_metadata_port(router, router_interfaces)
+        self._audit_gateway_port(router, router_interfaces)
+        self._audit_internal_ports(router, router_interfaces)
+        self._audit_snat_ports(router, router_interfaces)
+
+        # remove orphaned interfaces
+        for interface_uuid in router_interfaces.keys():
+            LOG.warning("AVR remove orphaned interface {}".
+                        format(interface_uuid))
+            self.vswitch_mgr.delete_interface(interface_uuid)
+
+    def _add_gateway_port(self, router):
+        port = router.get('gw_port', None)
+        if port:
+            name = self.vswitch_mgr.get_router_name(router['id'])
+            name += "-gwy"
+            self._add_router_port(router, port, name=name, gateway=True)
+            self._add_gateway_default_route(router, port)
+
+    def _delete_gateway_port(self, port):
+        self._delete_router_port(port)
+
+    def _update_gateway_port(self, router):
+        router_id = router.get('id')
+        current_port = router.get('gw_port', None)
+        existing_router = self.routers.get(router_id)
+        existing_port = existing_router.get('gw_port', None)
+
+        if not existing_port and current_port:
+            self._add_gateway_port(router)
+        elif existing_port and not current_port:
+            self._delete_gateway_port(existing_port)
+        else:
+            self._add_gateway_port(router)
+
+    def _audit_gateway_port(self, router, router_interfaces):
+        gw_port = router.get('gw_port', None)
+        if gw_port:
+            interface_uuid = gw_port.get('id')
+            if interface_uuid not in router_interfaces:
+                # add missing gateway port
+                LOG.warning("AVR add missing gateway port {}".
+                            format(interface_uuid))
+                self._add_gateway_port(router)
+            else:
+                # interface exists, and is not an orphan
+                del router_interfaces[interface_uuid]
+
+    def _get_existing_neighbours(self, interface_uuid):
+        data = self.vswitch_mgr.get_neighbours(interface_uuid)
+        neighbours = {}
+        for entry in data:
+            if entry['type'] != vswitch_constants.VSWITCH_NEIGH_STATIC:
+                continue
+            neighbours[entry['address']] = entry['mac-address']
+        return neighbours
+
+    def _add_subnet_static_arp_entries(self, interface_uuid, subnet):
+        subnet_id = subnet.get('id')
+        neighbours = self._get_existing_neighbours(interface_uuid)
+        ports = self.plugin_rpc.get_ports_by_subnet(self.context, subnet_id)
+        for port in ports:
+            if port['device_owner'] in ROUTER_OWNERS:
+                continue
+            for addr in port['fixed_ips'] or []:
+                if addr['subnet_id'] != subnet_id:
+                    continue
+                if addr['ip_address'] not in neighbours:
+                    self.vswitch_mgr.add_neighbour(interface_uuid,
+                                                   addr['ip_address'],
+                                                   port['mac_address'])
+                neighbours.pop(addr['ip_address'], None)
+        for ip_address, mac_address in six.iteritems(neighbours):
+            LOG.warning("Removing stale neighbour {} on {}".format(
+                ip_address, interface_uuid))
+            self.vswitch_mgr.delete_neighbour(interface_uuid, ip_address)
+
+    def _add_static_arp_entries(self, router, port):
+        interface_uuid = port.get('id')
+        for subnet in port['subnets']:
+            self._add_subnet_static_arp_entries(interface_uuid, subnet)
+
+    def _add_internal_ports(self, router):
+        ports = router.get(constants.INTERFACE_KEY, [])
+        for port in ports:
+            self._add_internal_port(router, port)
+
+    def _update_internal_ports(self, router):
+        router_id = router.get('id')
+        existing_router = self.routers.get(router_id)
+        current_ports = {port['id']: port for port in
+                         router.get(constants.INTERFACE_KEY, [])}
+        existing_ports = {port['id']: port for port in
+                          existing_router.get(constants.INTERFACE_KEY, [])}
+
+        current_set = set(current_ports)
+        existing_set = set(existing_ports)
+
+        added = current_set - existing_set
+        removed = existing_set - current_set
+        updated = existing_set & current_set
+
+        for port_id in removed:
+            self._delete_internal_port(existing_ports[port_id])
+        for port_id in added:
+            self._add_internal_port(router, current_ports[port_id])
+        for port_id in updated:
+            self._update_internal_port(router, current_ports[port_id])
+
+    def _audit_internal_ports(self, router, router_interfaces):
+        ports = router.get(constants.INTERFACE_KEY, [])
+        for port in ports:
+            interface_uuid = port.get('id')
+            if interface_uuid not in router_interfaces:
+                # add missing gateway port
+                LOG.warning("AVR add missing internal port {}".
+                            format(interface_uuid))
+                self._add_internal_port(router, port)
+            else:
+                # interface exists, and is not an orphan
+                del router_interfaces[interface_uuid]
+
+    def _add_internal_port(self, router, port):
+        self._add_router_port(router, port)
+        self._update_ndp_params(port)
+        if router.get('distributed', False):
+            self._add_static_arp_entries(router, port)
+
+    def _delete_internal_port(self, port):
+        self._delete_router_port(port)
+
+    def _update_internal_port(self, router, port):
+        self._add_router_port(router, port)
+        self._update_ndp_params(port)
+        if router.get('distributed', False):
+            self._add_static_arp_entries(router, port)
+
+    @staticmethod
+    def _translate_ndp_ra_mode(ramodes):
+        if constants.IPV6_SLAAC in ramodes:
+            return vswitch_constants.VSWITCH_NDP_RA_MODE_SLAAC
+        elif constants.DHCPV6_STATEFUL in ramodes:
+            return vswitch_constants.VSWITCH_NDP_RA_MODE_STATEFUL
+        elif constants.DHCPV6_STATELESS in ramodes:
+            return vswitch_constants.VSWITCH_NDP_RA_MODE_STATELESS
+        else:
+            return vswitch_constants.VSWITCH_NDP_RA_MODE_NONE
+
+    def _update_ndp_params(self, port):
+        interface_uuid = port.get('id')
+        ramodes = set()
+        for subnet in port.get('subnets'):
+            ramodes.add(subnet.get('ipv6_ra_mode'))
+        ramode = self._translate_ndp_ra_mode(ramodes)
+        params = {'ndp-interface-info':
+                  {'ra-mode': ramode}}
+        self.vswitch_mgr.update_interface(interface_uuid, params)
+
+    def _add_snat_ports(self, router):
+        ports = router.get(n_const.SNAT_ROUTER_INTF_KEY, [])
+        for port in ports:
+            self._add_snat_port(router, port)
+
+    def _update_snat_ports(self, router):
+        router_id = router.get('id')
+        existing_router = self.routers.get(router_id)
+
+        current_ports = {port['id']: port for port in
+                         router.get(n_const.SNAT_ROUTER_INTF_KEY, [])}
+        existing_ports = {port['id']: port for port in
+                          existing_router.get(
+                              n_const.SNAT_ROUTER_INTF_KEY, [])}
+
+        current_set = set(current_ports)
+        existing_set = set(existing_ports)
+
+        added = current_set - existing_set
+        removed = existing_set - current_set
+
+        if len(removed) > 0:
+            # The snat default route may be configured as the interface
+            # being removed, therefore replace the route with an interface
+            # that is still remaining before the interface is deleted
+            updated = current_set & existing_set
+            for port_id in updated:
+                self._update_snat_route(router, current_ports[port_id])
+                break  # only need one
+
+        for port_id in removed:
+            self._delete_snat_port(router, existing_ports[port_id])
+        for port_id in added:
+            self._add_snat_port(router, current_ports[port_id])
+
+    def _audit_snat_ports(self, router, router_interfaces):
+        if not self._is_gateway_owner(router):
+            return
+
+        ports = router.get(n_const.SNAT_ROUTER_INTF_KEY, [])
+        for port in ports:
+            interface_uuid = port.get('id')
+            if interface_uuid not in router_interfaces:
+                # add missing gateway port
+                LOG.warning("AVR add missing SNAT port {}".
+                            format(interface_uuid))
+                self._add_snat_port(router, port)
+            else:
+                # interface exists, and is not an orphan
+                del router_interfaces[interface_uuid]
+
+    def _add_snat_port(self, router, port):
+        if self._is_gateway_owner(router):
+            # router is the owner of the centralized snat port
+            name = self.vswitch_mgr.get_router_name(router['id'])
+            name += "-snat%u"
+
+            # SNAT interfaces are assigned a lower priority weight to ensure
+            # they are not selected as the internal network interface during
+            # next hop selection.
+            weight = self.conf.snat_interface_weight
+
+            self._add_router_port(router, port, weight=weight, name=name)
+        else:
+            # router must route packets to the centralized snat router
+            self._add_snat_default_route(router, port)
+
+    def _delete_snat_port(self, router, port):
+        if self._is_gateway_owner(router):
+            self._delete_router_port(port)
+
+    def _update_snat_route(self, router, port):
+        if not self._is_gateway_owner(router):
+            # attempt to replace the route in case it was configured by a
+            # different snat interface that may have be deleted
+            self._add_snat_default_route(router, port)
+
+    def _get_external_network_id(self, router):
+        info = router.get('external_gateway_info')
+        if info:
+            return info.get('network_id')
+        return None
+
+    def _add_fip_interface(self, router):
+        if not router.get('distributed'):
+            router.get('gw_port')
+
+        network_id = self._get_external_network_id(router)
+        port = self.agent_gateway_ports.get(network_id)
+        if port:
+            # validate that the cached port is configured, if not invalidate it
+            interface_uuid = port.get('id')
+            try:
+                self.vswitch_mgr.get_interface(interface_uuid)
+            except vswitch_manager.VSwitchManagerError:
+                self.agent_gateway_ports.pop(network_id)
+        self._add_agent_gateway_port(router)
+
+    def _get_fip_interface(self, router, create=False):
+        if not router.get('distributed', False):
+            return router.get('gw_port')
+        network_id = self._get_external_network_id(router)
+        interface = self.agent_gateway_ports.get(network_id)
+        if create and not interface:
+            return self._add_agent_gateway_port(router)
+        return interface
+
+    def _add_fip_router(self, router):
+        network_id = self._get_external_network_id(router)
+        port = self.agent_gateway_ports.get(network_id)
+        if port and (router['id'] in port['routers']):
+            # Already created and registered for this router
+            return port
+        elif port:
+            # Already created but not linked to this router
+            LOG.info("AVR Linking router {} to FIP router {}".format(
+                router['id'], network_id))
+            port['routers'].add(router['id'])
+            return port
+        LOG.info("AVR Add new FIP router {} for router {}".format(
+            network_id, router['id']))
+        port = self.plugin_rpc.get_agent_gateway_port(self.context, network_id)
+        # Create a router context
+        router_name = self.vswitch_mgr.get_fip_router_name(network_id)
+        self.vswitch_mgr.add_router(network_id, router_name)
+        # Create an interface from the router to the external network
+        fip_router = {'id': network_id}
+        name = "fip-" + network_id[:8]
+        self._add_router_port(fip_router, port, name=name, gateway=True)
+        self._add_gateway_default_route(fip_router, port)
+        # Setup the router association table and save the port
+        port['routers'] = set([router['id']])
+        self.agent_gateway_ports[network_id] = port
+        return port
+
+    def _delete_fip_router(self, router):
+        network_id = self._get_external_network_id(router)
+        if not network_id:
+            return
+        port = self.agent_gateway_ports.get(network_id)
+        if not port:
+            return
+        if router['id'] not in port['routers']:
+            LOG.warning("AVR router {} not holding reference "
+                        "to FIP router {}".
+                        format(router['id'], network_id))
+            return
+        port['routers'].remove(router['id'])
+        if len(port['routers']) != 0:
+            LOG.info("AVR Keeping FIP router {} with {} references: {}".
+                     format(network_id, len(port['routers']), port['routers']))
+            return
+        LOG.info("AVR Deleting orphaned FIP router {}".format(network_id))
+        self.vswitch_mgr.delete_router(network_id)
+        self.plugin_rpc.delete_agent_gateway_port(self.context, network_id)
+        del self.agent_gateway_ports[network_id]
+
+    def _add_agent_gateway_port(self, router):
+        if not router.get('distributed', False):
+            # No need for an agent gateway port
+            return
+        return self._add_fip_router(router)
+
+    def _update_agent_gateway_port(self, router):
+        if not router.get('distributed', False):
+            # No need for an agent gateway port
+            return
+        existing_router = self.routers[router['id']]
+        existing_network_id = self._get_external_network_id(existing_router)
+        current_network_id = self._get_external_network_id(router)
+        if existing_network_id == current_network_id:
+            return
+        if existing_network_id:
+            self._delete_fip_router(existing_router)
+        if current_network_id:
+            self._add_fip_router(router)
+
+    def _delete_agent_gateway_port(self, router):
+        if not router.get('distributed', False):
+            # No need for an agent gateway port
+            return
+        existing_network_id = self._get_external_network_id(router)
+        if existing_network_id:
+            self._delete_fip_router(router)
+
+    def _add_fip_address(self, router, interface, fip):
+        LOG.info("AVR Add FIP address {}".format(fip))
+        nat = {'internal-address': fip['fixed_ip_address'],
+               'router-uuid': fip['router_id']}
+        self.vswitch_mgr.add_address(fip['floating_ip_address'],
+                                     FLOATING_IP_PREFIX_LEN,
+                                     interface['id'],
+                                     **nat)
+
+    def _delete_fip_address(self, router, interface, fip):
+        if not interface:
+            LOG.error("AVR Delete FIP address has no interface {}".
+                      format(fip))
+        LOG.info("AVR Delete FIP address {}".format(fip))
+        self.vswitch_mgr.delete_address(fip['floating_ip_address'],
+                                        FLOATING_IP_PREFIX_LEN,
+                                        interface['id'])
+
+    def _get_floating_ips(self, router):
+        fips = router.get(constants.FLOATINGIP_KEY, [])
+        if router.get('distributed', False):
+            return [f for f in fips if f['host'] == self.host]
+        return fips
+
+    def _add_fip_addresses(self, router):
+        status = {}
+        fips = self._get_floating_ips(router)
+        if fips:
+            self._add_fip_interface(router)
+        interface = self._get_fip_interface(router)
+        for fip in fips:
+            self._add_fip_address(router, interface, fip)
+            status[fip['id']] = constants.FLOATINGIP_STATUS_ACTIVE
+        self.plugin_rpc.update_floatingip_statuses(
+            self.context, router['id'], status)
+
+    def _update_fip_addresses(self, router):
+        existing_router = self.routers[router['id']]
+        fips = self._get_floating_ips(router)
+        current_fips = {f['id']: f for f in fips}
+        fips = self._get_floating_ips(existing_router)
+        existing_fips = {f['id']: f for f in fips}
+        # Calculate the delta between the old and new router
+        added = set(current_fips) - set(existing_fips)
+        removed = set(existing_fips) - set(current_fips)
+        # Create an agent gateway port if necessary
+        existing_interface = self._get_fip_interface(existing_router)
+        interface = self._get_fip_interface(router, create=bool(current_fips))
+        # Adjust the local floating ip addresses
+        status = {}
+        for fip_id in removed:
+            self._delete_fip_address(
+                router, existing_interface, existing_fips[fip_id])
+            status[fip_id] = constants.FLOATINGIP_STATUS_DOWN
+        for fip_id in added:
+            self._add_fip_address(router, interface, current_fips[fip_id])
+            status[fip_id] = constants.FLOATINGIP_STATUS_ACTIVE
+        self.plugin_rpc.update_floatingip_statuses(
+            self.context, router['id'], status)
+        if existing_fips and not current_fips:
+            # The neutron-server automatically deletes the port when the last
+            # FIP is deleted on a DVR router so we need to do the same.
+            self._delete_agent_gateway_port(router)
+
+    def _audit_fip_addresses(self, local_router):
+        router_id = local_router.get('id')
+        fips = self._get_floating_ips(local_router)
+        local_addresses = {f['floating_ip_address']: f for f in fips}
+        remote_addresses = \
+            {a['address']: a for a in
+             self.vswitch_mgr.get_router_fip_addresses(router_id)}
+
+        local = set(local_addresses)
+        remote = set(remote_addresses)
+
+        missing = local - remote
+        orphaned = remote - local
+
+        interface = self._get_fip_interface(local_router, create=bool(fips))
+        for addr in missing:
+            LOG.warning("AVR add missing FIP address {}".format(addr))
+            self._add_fip_address(local_router, interface,
+                                  local_addresses[addr])
+
+        for addr in orphaned:
+            LOG.warning("AVR remove orphan FIP address {}".format(addr))
+            self.vswitch_mgr.delete_address(addr,
+                                            FLOATING_IP_PREFIX_LEN,
+                                            interface['id'])
+
+    def _get_dnat_rules(self, router):
+        snat_enabled = router.get('enable_snat', False)
+        dnat_rules = router.get(n_const.PORTFORWARDING_KEY, [])
+        gw_port = router.get('gw_port')
+        if not snat_enabled or not gw_port or not dnat_rules:
+            return []
+        return dnat_rules
+
+    def _add_dnat_rule(self, router, rule):
+        gw_port = router.get('gw_port')
+        if gw_port:
+            LOG.info("AVR adding DNAT rule {}".format(rule))
+            self.vswitch_mgr.add_snat_entry(gw_port['id'],
+                                            rule['inside_addr'],
+                                            rule['inside_port'],
+                                            rule['outside_port'],
+                                            rule['protocol'])
+
+    def _delete_dnat_rule(self, router, rule):
+        gw_port = router.get('gw_port')
+        if gw_port:
+            LOG.info("AVR removing DNAT rule {}".format(rule))
+            self.vswitch_mgr.delete_snat_entry(gw_port['id'],
+                                               rule['inside_addr'],
+                                               rule['inside_port'],
+                                               rule['protocol'])
+
+    def _add_dnat_rules(self, router):
+        dnat_rules = self._get_dnat_rules(router)
+        if not dnat_rules:
+            # Nothing to do
+            return
+        for rule in dnat_rules:
+            self._add_dnat_rule(router, rule)
+
+    def _make_dnat_key(self, rule):
+        """
+        Create a dictionary key string that can be used to compare unique
+        values in the local config versus the AVS config.  This is required
+        because AVS does not have a UUID against each SNAT entry and the local
+        config does.  We use this key to compare the 2 sets instead of a UUID
+        value.
+        """
+        return "{}-{}-{}-{}".format(rule['inside_addr'],
+                                    rule['inside_port'],
+                                    rule['outside_port'],
+                                    rule['protocol'].lower())
+
+    def _update_dnat_rules(self, router):
+        router_id = router.get('id')
+        existing_router = self.routers.get(router_id)
+        dnat_rules = self._get_dnat_rules(existing_router)
+        existing_dnat_rules = {self._make_dnat_key(d): d for d in dnat_rules}
+        dnat_rules = self._get_dnat_rules(router)
+        current_dnat_rules = {self._make_dnat_key(d): d for d in dnat_rules}
+        # Calculate the delta between the old and new router
+        added = set(current_dnat_rules) - set(existing_dnat_rules)
+        removed = set(existing_dnat_rules) - set(current_dnat_rules)
+        # Adjust the installed DNAT rules
+        for key in removed:
+            self._delete_dnat_rule(router, existing_dnat_rules[key])
+        for key in added:
+            self._add_dnat_rule(router, current_dnat_rules[key])
+
+    def _get_avs_dnat_rules(self, router):
+        gw_port = router.get('gw_port')
+        if not gw_port:
+            return []
+        static_snat_rules = self.vswitch_mgr.get_snat_entries(gw_port['id'])
+        # Normalize the list of AVS SNAT rules to provide the equivalent
+        # neutron DNAT rule dict.
+        return [{'inside_addr': s['src-address'],
+                 'inside_port': s['src-proto-key'],
+                 'outside_port': s['nat-proto-key'],
+                 'protocol': s['protocol'].lower()} for s in static_snat_rules]
+
+    def _audit_dnat_rules(self, router):
+        dnat_rules = self._get_dnat_rules(router)
+        local_dnat_rules = {self._make_dnat_key(d): d for d in dnat_rules}
+        dnat_rules = self._get_avs_dnat_rules(router)
+        avs_dnat_rules = {self._make_dnat_key(d): d for d in dnat_rules}
+        # Calculate the delta between the local config and the AVS config
+        missing = set(local_dnat_rules) - set(avs_dnat_rules)
+        stale = set(avs_dnat_rules) - set(local_dnat_rules)
+        # Adjust the installed DNAT rules
+        for key in stale:
+            self._delete_dnat_rule(router, avs_dnat_rules[key])
+        for key in missing:
+            self._add_dnat_rule(router, local_dnat_rules[key])
+
+    def _add_router_port(self, router, port, weight=None, name=None,
+                         gateway=False):
+        LOG.info("AVR add router port: {}".format(port))
+
+        router_id = router.get('id')
+        interface_uuid = port.get('id')
+        mac_address = port.get('mac_address')
+        mtu = port.get(wrs_binding.MTU, n_const.DEFAULT_MTU)
+
+        self.vswitch_mgr.add_router_interface(
+            interface_uuid, router_id, mac_address, mtu,
+            weight=weight, name=name, gateway=gateway)
+
+        self._add_port_addresses(port)
+
+    def _delete_router_port(self, port):
+        LOG.info("AVR delete router port: {}".format(port))
+
+        interface_uuid = port.get('id')
+        self.vswitch_mgr.delete_interface(interface_uuid)
+
+    def _remove_stale_addresses(self, port):
+        """
+        remove stale address entries from the port but exclude automatically
+        acquired addresses, floating-ip address and any link-local addresses.
+        """
+        interface_uuid = port.get('id')
+        addresses = self.vswitch_mgr.get_address_list(
+            interface_uuid=interface_uuid)
+
+        ips = port.get('fixed_ips', [])
+        for ip in ips:
+            address = ip.get('ip_address')
+            if address in addresses:
+                del addresses[address]
+
+        for k, a in six.iteritems(addresses):
+            if (getattr(a, 'floating-ip', False) or
+                    getattr(a, 'autoconf', False)):
+                continue
+            address = netaddr.IPAddress(a['address'])
+            if address.is_link_local():
+                continue
+            LOG.warning("AVR deleting stale address: {} from {}".format(
+                a['address'], interface_uuid))
+            self.vswitch_mgr.delete_address(
+                a['address'], a['prefix-length'], interface_uuid)
+
+    def _add_port_addresses(self, port):
+        # Remove stale addresses before adding new ones to avoid a deficiency
+        # in AVS in how the prefix routes are handled when there are multiple
+        # addresses from the same subnet on the same interface (i.e., deleting
+        # one address in a subnet when another still exists will accidentally
+        # remove the related prefix route which will break further LPM lookups
+        # in that same subnet).
+        self._remove_stale_addresses(port)
+        ips = port.get('fixed_ips', [])
+        for ip in ips:
+            address = ip.get('ip_address')
+            prefixlen = ip.get('prefixlen')
+            self._add_port_address(port, address, prefixlen)
+
+    def _add_port_address(self, port, address, prefixlen):
+        LOG.info("AVR add port address: {}/{} to port {}".
+                 format(address, prefixlen, port))
+        interface_uuid = port.get('id')
+        self.vswitch_mgr.add_address(address, prefixlen, interface_uuid)
+
+    def _delete_port_address(self, port, address, subnet):
+        LOG.info("AVR add port address: {} from {}".format(address, port))
+
+        interface_uuid = port.get('id')
+        prefixlen = netaddr.IPNetwork(subnet['cidr']).prefixlen
+        self.vswitch_mgr.delete_address(address, prefixlen, interface_uuid)
+
+    @staticmethod
+    def _get_default_route_prefix(subnet):
+        cidr = netaddr.IPNetwork(subnet['cidr'])
+        return '0.0.0.0' if cidr.version == 4 else '::'
+
+    def _get_gateway_subnets(self, port):
+        subnets = {}
+        for subnet in port.get('subnets'):
+            if subnet.get('gateway_ip'):
+                cidr = netaddr.IPNetwork(subnet['cidr'])
+                subnets.setdefault(cidr.version, [])
+                subnets[cidr.version].append(subnet)
+        return subnets
+
+    def _add_gateway_default_route(self, router, port):
+        interface_uuid = port.get('id')
+        for version, subnets in self._get_gateway_subnets(port).items():
+            if len(subnets) > 1:
+                LOG.warning(
+                    "AVR gateway port {} has multiple ({}) subnets".format(
+                        interface_uuid, len(subnets)))
+            subnet = subnets[0]
+            gateway = subnet.get('gateway_ip')
+            prefix = self._get_default_route_prefix(subnet)
+            prefixlen = 0
+            self._add_router_route(router, prefix, prefixlen,
+                                   interface_uuid, gateway)
+
+    def _add_snat_default_route(self, router, port):
+        # TODO(alegacy) not sure if it is possible to have multiple subnets on
+        # the SNAT port.
+        interface_uuid = port.get('id')
+        subnets = port.get('subnets')
+        if len(subnets) != 1:
+            LOG.warning("AVR SNAT port {} has multiple ({}) subnets".
+                        format(interface_uuid, len(subnets)))
+        subnet = subnets[0]
+        # default route via centralized snat router interface
+        gateway = port['fixed_ips'][0]['ip_address']
+        prefix = self._get_default_route_prefix(subnet)
+        prefixlen = 0
+        self._add_router_route(router, prefix, prefixlen, None, gateway,
+                               replace=True)
+
+    def _add_routes(self, router):
+        routes = router.get('routes', [])
+        for route in routes:
+            self._add_route(router, route)
+
+    def _update_routes(self, router):
+        router_id = router.get('id')
+        existing_router = self.routers.get(router_id)
+
+        new_routes = router.get('routes', [])
+        old_routes = existing_router.get('routes', [])
+
+        added, removed = helpers.diff_list_of_dict(old_routes, new_routes)
+        for route in removed:
+            self._delete_route(router, route)
+        for route in added:
+            self._add_route(router, route)
+
+    @staticmethod
+    def _transform_remote_routes(routes):
+        """Transform a route retrieved from vswitch into a neutron route"""
+        for r in routes:
+            # only the router "extra-routes" are considered, therefore filter
+            # out the default route and prefix routes
+            if int(r['prefix-length']) != 0 and r['type'] == 'external':
+                for n in r.nexthops:
+                    yield {
+                        'destination': "%s/%s" % (r['prefix'],
+                                                  r['prefix-length']),
+                        'nexthop': n['gateway']
+                    }
+
+    def _audit_routes(self, local_router):
+        router_id = local_router.get('id')
+        local_routes = local_router.get('routes', [])
+        remote_routes = self._transform_remote_routes(
+            self.vswitch_mgr.get_router_routes(router_id))
+
+        orphaned, missing = helpers.diff_list_of_dict(local_routes,
+                                                      remote_routes)
+
+        for route in orphaned:
+            LOG.warning("AVR remove orphaned route {}".format(route))
+            self._delete_route(local_router, route)
+
+        for route in missing:
+            LOG.warning("AVR add missing route {}".format(route))
+            self._add_route(local_router, route)
+
+    def _add_route(self, router, route):
+        destination = netaddr.IPNetwork(route['destination'])
+        gateway = route.get('nexthop')
+        prefix = destination.ip
+        prefixlen = destination.prefixlen
+        self._add_router_route(router, prefix, prefixlen, None, gateway)
+
+    def _delete_route(self, router, route):
+        destination = netaddr.IPNetwork(route['destination'])
+        prefix = destination.ip
+        prefixlen = destination.prefixlen
+        self._delete_router_route(router, prefix, prefixlen)
+
+    def _add_router_route(self, router, prefix, prefixlen,
+                          interface_uuid, gateway, replace=False):
+        LOG.info("AVR add router route: {}/{} via {} {}".format(
+            prefix, prefixlen, interface_uuid, gateway))
+
+        router_id = router.get('id')
+        self.vswitch_mgr.add_route(router_id, prefix, prefixlen,
+                                   interface_uuid, gateway, replace)
+
+    def _delete_router_route(self, router, prefix, prefixlen):
+        LOG.info("AVR delete router route: {}/{}".format(
+            prefix, prefixlen))
+
+        router_id = router.get('id')
+        self.vswitch_mgr.delete_route(router_id, prefix, prefixlen)
+
+    @staticmethod
+    def _get_router_namespace(router_id):
+        return ROUTER_NS_PREFIX + router_id
+
+    def _create_namespace(self, name):
+        ip_wrapper_root = ip_lib.IPWrapper()
+        ip_ns = ip_wrapper_root.ensure_namespace(name)
+        ip_ns.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])
+        ip_ns.netns.execute(['sysctl', '-w', 'net.ipv6.conf.all.forwarding=1'])
+
+    def _delete_namespace(self, name):
+        ip_ns = ip_lib.IPWrapper(namespace=name)
+        try:
+            ip_ns.netns.delete(name)
+        except RuntimeError:
+            msg = 'Failed trying to delete namespace: %s' % name
+            LOG.exception(msg)
+
+    def _get_metadata_proxy_callback(self, router_id):
+        cfg_file = '/etc/neutron/haproxy_router.cfg'
+
+        def callback(pid_file):
+            proxy_cmd = ['haproxy',
+                         '-D',
+                         '-p',
+                         '%s' % pid_file,
+                         '-f',
+                         '%s' % cfg_file]
+            return proxy_cmd
+
+        return callback
+
+    def _get_metadata_proxy_process_manager(self, router_id, ns_name,
+                                            addl_env=None):
+        return external_process.ProcessManager(
+            self.conf,
+            router_id,
+            ns_name,
+            cmd_addl_env=addl_env)
+
+    def _add_metadata_ips(self, router_id, device_name, namespace):
+        device = ip_lib.IPDevice(device_name, namespace=namespace)
+
+        # Add the local metadata IP address
+        ip_cidr = METADATA_DEFAULT_CIDR
+        try:
+            if ip_cidr not in (ip['cidr'] for ip in device.addr.list()):
+                device.addr.add(ip_cidr)
+        except RuntimeError:
+            LOG.warning("Unable to configure IP address for "
+                        "Metadata proxy: %s", ip_cidr)
+
+        # Add the router IP address
+        self.vswitch_mgr.add_address(METADATA_ROUTER_IP,
+                                     METADATA_DEFAULT_PREFIX,
+                                     router_id)
+
+    def _add_metadata_default_route(self, device_name, namespace):
+        ipd = ip_lib.IPDevice(device_name, namespace=namespace)
+        ipd.route.add_gateway(METADATA_ROUTER_IP)
+
+    def _get_metadata_device_name(self, router_id):
+        return (METADATA_DEV_PREFIX + router_id)[:self.vif_driver.DEV_NAME_LEN]
+
+    def _create_metadata_port(self, router_id, ns_name):
+        interface_name = self._get_metadata_device_name(router_id)
+        self._create_metadata_host_port(router_id,
+                                        interface_name,
+                                        self.conf.metadata_mac_address,
+                                        n_const.DEFAULT_MTU,
+                                        namespace=ns_name)
+        self._add_metadata_ips(router_id, interface_name, ns_name)
+        self._add_metadata_default_route(interface_name, ns_name)
+
+    def _destroy_metadata_port(self, router_id, ns_name):
+        interface_name = self._get_metadata_device_name(router_id)
+        self._destroy_metadata_host_port(router_id,
+                                         interface_name,
+                                         namespace=ns_name)
+
+    def _audit_metadata_port(self, router, router_interfaces):
+        router_id = router.get('id')
+        interface_uuid = self._get_metadata_port_uuid(router_id)
+        if interface_uuid not in router_interfaces:
+            self._spawn_metadata_proxy(router)
+        else:
+            # interface exists, and is not an orphan
+            del router_interfaces[interface_uuid]
+
+    def _spawn_metadata_proxy(self, router):
+        if not self.conf.enable_metadata_proxy:
+            return
+
+        router_id = router.get('id')
+        ns_name = self._get_router_namespace(router_id)
+
+        self._create_namespace(ns_name)
+        self._create_metadata_port(router_id, ns_name)
+        callback = self._get_metadata_proxy_callback(router_id)
+        addl_env = {'HEADER_VALUE': router_id}
+        pm = self._get_metadata_proxy_process_manager(router_id, ns_name,
+                                                      addl_env)
+        if not pm.active:
+            pm.enable(callback)
+
+    def _destroy_metadata_proxy(self, router):
+        if not self.conf.enable_metadata_proxy:
+            return
+
+        router_id = router.get('id')
+        ns_name = self._get_router_namespace(router_id)
+
+        self._destroy_metadata_port(router_id, ns_name)
+        pm = self._get_metadata_proxy_process_manager(router_id, ns_name)
+        pm.disable()
+        if self.conf.router_delete_namespaces:
+            self._delete_namespace(ns_name)
+
+    def _get_metadata_port_uuid(self, router_id):
+        # return str(uuid.uuid5(uuid.UUID(router_id), router_id))
+        return router_id
+
+    def _create_metadata_host_port(self, router_id, device_name, mac_address,
+                                   mtu, namespace=None):
+        port_id = self._get_metadata_port_uuid(router_id)
+        ip_wrapper = ip_lib.IPWrapper()
+        ip_ns = ip_wrapper.ensure_namespace(namespace)
+        if not ip_lib.device_exists(device_name,
+                                    namespace=namespace):
+            self.vswitch_mgr.add_port(port_id, device_name,
+                                      mac_address, mtu, neutron=False)
+            self.vswitch_mgr.attach_router_interface(router_id, port_id)
+            self.vswitch_mgr.unlock_port(port_id)
+
+            # Get a reference to the device for link operations
+            device = ip_wrapper.device(device_name)
+
+            # Attempt to move the device to a namespace
+            ip_ns.add_device_to_namespace(device)
+            LOG.info("Device %(name)s has been added "
+                     "to namespace %(namespace)s",
+                     {'name': device_name, 'namespace': namespace})
+        else:
+            LOG.info("Device %s already exists", device_name)
+            # ensure it is attached to the router
+            self.vswitch_mgr.attach_router_interface(router_id, port_id)
+            # Get a reference to the device for link operations
+            device = ip_ns.device(device_name)
+
+        # Attempt to set the interface MTU
+        mtu_value = mtu if mtu else self.conf.network_device_mtu
+        if mtu_value:
+            device.link.set_mtu(mtu_value)
+        # Attempt to bring up linux interface
+        device.link.set_up()
+        LOG.info("Device %s has been set to up", device_name)
+
+    def _destroy_metadata_host_port(self, router_id, device_name,
+                                    namespace=None):
+        if ip_lib.device_exists(device_name,
+                                namespace=namespace):
+            port_id = self._get_metadata_port_uuid(router_id)
+            self.vswitch_mgr.destroy_port(port_id)
+
+
+def _register_opts(conf):
+    conf.register_opts(AVRAgentManager.OPTS)
+    config.register_interface_driver_opts_helper(conf)
+    config.register_agent_state_opts_helper(conf)
+    config.register_availability_zone_opts_helper(conf)
+    config.register_root_helper(conf)
+    conf.register_opts(interface.OPTS)
+    conf.register_opts(external_process.OPTS)
+
+
+def main(manager='neutron.plugins.wrs.agent.avr.agent.AVRAgentManager'):
+    _register_opts(cfg.CONF)
+    common_config.init(sys.argv[1:])
+    config.setup_logging()
+    server = neutron_service.Service.create(
+        binary='neutron-avr-agent',
+        topic=topics.L3_AGENT,
+        report_interval=cfg.CONF.AGENT.report_interval,
+        manager=manager)
+    service.launch(cfg.CONF, server).wait()
diff --git a/neutron/plugins/wrs/agent/avs/__init__.py b/neutron/plugins/wrs/agent/avs/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/plugins/wrs/agent/avs/agent.py b/neutron/plugins/wrs/agent/avs/agent.py
new file mode 100644
index 0000000..d9824c5
--- /dev/null
+++ b/neutron/plugins/wrs/agent/avs/agent.py
@@ -0,0 +1,1934 @@
+#!/usr/bin/env python
+#
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2016 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+import collections
+import copy
+import socket
+import sys
+import threading
+import time
+
+import eventlet
+eventlet.monkey_patch()
+
+from neutron_lib import constants
+from neutron_lib import context
+from oslo_config import cfg
+from oslo_log import log as logging
+import oslo_messaging
+from oslo_service import loopingcall
+from oslo_utils import uuidutils
+import six
+from tsconfig import tsconfig
+
+from neutron._i18n import _
+from neutron.agent import fm as agent_fm
+from neutron.agent import rpc as agent_rpc
+from neutron.agent import securitygroups_rpc as sg_rpc
+from neutron.agent.vswitch import api
+from neutron.agent.vswitch import constants as avs_constants
+from neutron.agent.vswitch import manager
+from neutron.agent.vswitch import vif_api
+from neutron.api.rpc.handlers import dvr_rpc
+from neutron.api.rpc.handlers import qos_rpc
+from neutron.common import config as common_config
+from neutron.common import constants as n_const
+from neutron.common import ipv6_utils
+from neutron.common import rpc as n_rpc
+from neutron.common import topics
+from neutron.conf.agent import common as config
+from neutron.drivers import fm
+from neutron.extensions import securitygroup as ext_sg
+from neutron.extensions import wrs_provider
+from neutron.plugins.wrs.agent.avs import dvr
+
+
+avs_opts = [
+    cfg.BoolOpt('remove_stale_ports', default=False,
+                help=_("Enable stale port audit which removes ports that do "
+                       "not exist in the DB")),
+    cfg.StrOpt('maintenance_host', default='localhost',
+               help=_("The host name of the maintenance client "
+                      "event listener.")),
+    cfg.IntOpt('maintenance_port', default=2303,
+               help=_("The port number of the maintenance client "
+                      "event listener.")),
+    cfg.IntOpt('status_interval', default=30,
+               help=_("The status reporting interval for tracked resources.")),
+    cfg.IntOpt('polling_interval', default=2,
+               help=_("The number of seconds the agent will wait between "
+                      "polling for local device changes.")),
+    cfg.IntOpt('metering_interval', default=30,
+               help=_("The number of seconds the agent will wait between "
+                      "sending metering notification events.")),
+    cfg.BoolOpt('managed_host_state', default=False,
+                help=_("If false, then host_state_up is always set to true, "
+                       "rather than making a call to get_host_details()")),
+    cfg.BoolOpt('report_port_status', default=False,
+                help=_("If false, then no fault state reports are "
+                       "generated.")),
+    cfg.BoolOpt('managed_providers', default=False,
+                help=_("If false, then provider details are not queried "
+                       "from the server; local config is used instead.")),
+]
+
+agent_opts = [
+    cfg.ListOpt('physical_interface_mappings',
+                default=[],
+                help=_("List of <physical_interface>:<physical_network>")),
+    cfg.BoolOpt('enable_distributed_routing',
+                default=False,
+                help=_("Enable distributed virtual routing")),
+]
+
+vxlan_opts = [
+    cfg.StrOpt('default_group',
+               default=n_const.DEFAULT_VXLAN_GROUP,
+               help=_("Defines the default multicast group to use for "
+                      "VXLAN interfaces")),
+    cfg.IntOpt('default_port',
+               default=n_const.DEFAULT_VXLAN_UDP_PORT,
+               help=_("Defines the default destination UDP port to use for "
+                      "VXLAN interfaces ")),
+    cfg.IntOpt('default_ttl',
+               default=n_const.DEFAULT_VXLAN_TTL,
+               help=_("Defines the default time-to-live value to use for "
+                      "VXLAN interfaces"))
+]
+
+sdn_opts = [
+    cfg.BoolOpt('manage_external_networks',
+                default=False,
+                help=_("Defines whether to manage the creation of the "
+                       "external network bridge or to defer this task to the "
+                       "SDN controller.  The integration bridge is always "
+                       "managed by the SDN controller.")),
+    cfg.StrOpt('integration_bridge_name',
+               default='br-int',
+               help=_("Defines the default integration bridge name")),
+    cfg.StrOpt('external_bridge_name',
+               default='br-ex',
+               help=_("Defines the default external bridge name")),
+]
+
+
+LOG = logging.getLogger(__name__)
+
+LB_PORT_NAME_PREFIX = "tap"
+LB_PORT_UUID_TAP_LEN = 11
+
+# Interface status severity
+INTERFACE_SEVERITY_CLEAR = fm.FM_SEVERITY_CLEAR
+INTERFACE_SEVERITY_MAJOR = fm.FM_SEVERITY_MAJOR
+INTERFACE_SEVERITY_CRITICAL = fm.FM_SEVERITY_CRITICAL
+
+# DVR MAC Address Audit Interval in seconds
+DVR_MAC_ADDRESS_AUDIT_INTERVAL = 10
+
+# Fault Audit Interval in seconds
+FAULT_AUDIT_INTERVAL = 60
+
+# Represents the list of neutron device owner values that are mapped to an
+# actual AVS port rather than an AVS interface.
+#
+AVS_VIRTUAL_PORT_TYPES = [constants.DEVICE_OWNER_DHCP, ]
+
+# Represents the list of neutron device owner values that are associated with
+# external bridges when running in SDN mode
+#
+DEVICES_ON_EXTERNAL_NETWORKS = [constants.DEVICE_OWNER_ROUTER_GW,
+                                constants.DEVICE_OWNER_AGENT_GW]
+
+
+def is_avs_port(device_owner):
+    """
+    Determine whether a device is represented by an AVS port rather than an AVS
+    interface.
+    """
+    if device_owner in AVS_VIRTUAL_PORT_TYPES:
+        return True
+    elif device_owner.startswith('compute:'):
+        return True
+    return False
+
+
+def is_vlan_capable_port(device_owner):
+    """
+    Determine whether a device is capable of VLAN interfaces.  Only devices
+    directly related to VM instances are capable of VLAN interfaces.  All DHCP
+    ports and router interfaces attach only to a single layer2 segment
+    therefore they always have an untagged interface regardless of whether
+    their layer2 segment maps to a VLAN subnet.  This information is used to
+    determine which layer2 segments to attach when a port is detected.
+
+    * For VM ports we always attach the network segment, any vlan subnet
+      segments, and any trunk subport segments regardless of whether the VM has
+      an IP address on any of those segments.
+    * For DHCP ports and Router interfaces we examine the list of IP addresses
+      on the port and determine which subnet is active (there can only be
+      one).  We use that subnet's VLAN to determine which layer2 segment to
+      attach but do so as an untagged interface as the DHCP and Router
+      implementations are unaware of VLAN interfaces.
+    """
+    if device_owner.startswith('compute:'):
+        return True
+    return False
+
+
+class VSwitchBaseRpcCallbacksMixin(object):
+
+    def port_update(self, context, **kwargs):
+        """
+        RPC request handler to service data updates on ports from plugin.
+        """
+        port = kwargs.get('port')
+        LOG.debug("RPC port_update received %(port)s", locals())
+        if not self.is_port_present(port['id']):
+            # Since this command only expects to update ports that have already
+            # been setup properly we need to ignore any updates until the port
+            # has been discovered and attached to its network
+            #
+            LOG.debug("Ignoring port_update for {} until auto-discovered".
+                      format(port['id']))
+            return
+
+        device_owner = port.get('device_owner')
+        if device_owner and is_avs_port(device_owner):
+            # Only neutron ports that map to an AVS port (i.e., a router
+            # interface is an interface in AVS and not a port and as such does
+            # not support a lock/unlock action).  The server state has changed
+            # for this port so force it to run through our update path to make
+            # sure that we send up our latest local state.
+            self.mark_port_for_refresh(port['id'])
+
+    def network_delete(self, context, **kwargs):
+        """
+        RPC request handler to service network delete operations from plugin.
+        """
+        network_id = kwargs.get('network_id')
+        LOG.debug("RPC network_delete received %(network_id)s", locals())
+        networks = self.virtual_networks
+        in_use_interfaces = self._pnet_connectivity_interface_uuids()
+        if network_id in networks:
+            network = networks[network_id]
+            if network['type'] == avs_constants.VSWITCH_LAYER2_NETWORK:
+                self.vswitch_mgr.delete_network(network_id, in_use_interfaces)
+                self.virtual_networks.pop(network_id, None)
+
+    def agent_updated(self, context, payload):
+        """Handle the agent_updated notification event."""
+        LOG.info("agent_updated by server side %s", payload)
+        self.admin_state_up = payload['admin_state_up']
+
+    def host_updated(self, context, payload):
+        """Handle the host_updated notification event."""
+        LOG.info("host_updated by server side %s", payload)
+        self.host_state_up = payload['host_state_up']
+
+
+class VSwitchRpcCallbacksMixin(VSwitchBaseRpcCallbacksMixin,
+                               sg_rpc.SecurityGroupAgentRpcCallbackMixin,
+                               qos_rpc.QoSAgentRpcCallbackMixin,
+                               dvr_rpc.DVRAgentRpcCallbackMixin):
+
+    # Set RPC API version to 1.0 by default.
+    # history
+    #   1.1 Support Security Group RPC
+    #   1.2 Support QoS RPC
+    #   1.3 Support DVR (Distributed Virtual Router) RPC
+
+    target = oslo_messaging.Target(version='1.2')
+
+    def port_update(self, context, **kwargs):
+        """
+        RPC request handler to service data updates on ports from plugin.
+        """
+        port = kwargs.get('port')
+        if not self.is_port_present(port['id']):
+            # Since this command only expects to update ports that have already
+            # been setup properly we need to ignore any updates until the port
+            # has been discovered and attached to its network
+            #
+            LOG.debug("Ignoring port_update for {} until auto-discovered".
+                      format(port['id']))
+            return
+
+        if ext_sg.SECURITYGROUPS in port:
+            devices = [VSwitchNeutronAgent._get_device_name(port['id'])]
+            if port[ext_sg.SECURITYGROUPS]:
+                self.sg_agent.prepare_devices_filter(devices)
+                self.sg_agent.refresh_firewall()
+            else:
+                self.sg_agent.remove_devices_filter(devices)
+
+        super(VSwitchRpcCallbacksMixin, self).port_update(context, **kwargs)
+
+    def subnet_create(self, context, **kwargs):
+        """
+        RPC request handler to service subnet create operations from plugin.
+        """
+        LOG.debug("RPC subnet_create received {}".format(kwargs))
+        subnet = kwargs.get('subnet')
+
+        # subnets without a vlan do not need a seperate network segment
+        if not subnet['vlan_id']:
+            return
+
+        # obtain the ports that may need to be updated
+        virtual_ports = self.vswitch_mgr.get_virtual_port_list()
+        for port_uuid, port in six.iteritems(virtual_ports):
+            self.mark_port_for_refresh(port_uuid)
+
+    def subnet_delete(self, context, **kwargs):
+        """
+        RPC request handler to service subnet delete operations from plugin.
+        """
+        LOG.debug("RPC subnet_delete received {}".format(kwargs))
+        subnet = kwargs.get('subnet')
+
+        # subnets without a vlan do not have a seperate network segment
+        if not subnet['vlan_id']:
+            return
+
+        network_uuid = self.vswitch_mgr.get_network_uuid(
+            subnet['network_id'], vlan_id=subnet['vlan_id'])
+        try:
+            # Do not delete interfaces in use for pnet connectivity testing
+            in_use_interfaces = self._pnet_connectivity_interface_uuids()
+            self.vswitch_mgr.delete_network(network_uuid, in_use_interfaces)
+            self.virtual_networks.pop(network_uuid, None)
+
+        except manager.VSwitchManagerError as e:
+            # network may not exist if subnet is not associated with a
+            # vlan or if there are no guest ports attached to this network
+            LOG.debug("Failed to delete subnet network: "
+                      "{}, {}".format(network_uuid, e))
+
+
+class VSwitchSdnRpcCallbacksMixin(VSwitchBaseRpcCallbacksMixin):
+
+    def subnet_create(self, context, **kwargs):
+        # Nothing to be done for SDN
+        pass
+
+    def subnet_delete(self, context, **kwargs):
+        # Nothing to be done for SDN
+        pass
+
+
+class VSwitchSecurityGroupAgentRpc(sg_rpc.SecurityGroupAgentRpc):
+
+    def register_manager(self, manager):
+        if hasattr(self.firewall, 'register_manager'):
+            self.firewall.register_manager(manager)
+
+    @property
+    def use_enhanced_rpc(self):
+        # FIXME(alegacy) we do not yet support the new, more compact, form of
+        # security group rule queries.  Until we do we need to force the use
+        # of the legacy code by returning false with this method
+        return False
+
+
+class VSwitchNetworkSegmentInterface(object):
+
+    def __init__(self, providernet_id, providernet_name, providernet_type,
+                 segment, interface_uuid):
+        self.providernet_id = providernet_id
+        self.providernet_name = providernet_name
+        self.providernet_type = providernet_type
+        self.segment = segment
+        self.interface_uuid = interface_uuid
+
+
+class VSwitchBaseNeutronAgent(vif_api.VifAgentListenerMixin,
+                              agent_fm.FmAgentMixin):
+
+    def __init__(self,
+                 interface_mappings,
+                 polling_interval,
+                 metering_interval,
+                 status_interval,
+                 vswitch_api,
+                 enable_distributed_routing=False):
+        super(VSwitchBaseNeutronAgent, self).__init__()
+        self.admin_state_up = True
+        self.host_state_up = None
+        self.interface_mappings = interface_mappings
+        self.polling_interval = polling_interval
+        self.metering_interval = metering_interval
+        self.status_interval = status_interval
+        self.enable_distributed_routing = enable_distributed_routing
+        self.vswitch_mgr = manager.VSwitchManager(
+            vswitch_api, interface_mappings)
+        self._notifier = n_rpc.get_notifier('metering')
+        self.host = cfg.CONF.host
+        self.agent_state = {
+            'binary': 'neutron-avs-agent',
+            'host': self.host,
+            'availability_zone': cfg.CONF.AGENT.availability_zone,
+            'topic': constants.L2_AGENT_TOPIC,
+            'configurations': {'mappings': interface_mappings,
+                               'enable_distributed_routing':
+                               self.enable_distributed_routing},
+            'agent_type': n_const.AGENT_TYPE_WRS_VSWITCH,
+            'start_flag': True}
+        self.setup_vif_listener()
+        self.setup_rpc()
+        self.init_fm()
+        self.port_details = {}
+        self.interface_details = {}
+        self.port_stats = {}
+        self.virtual_ports = {}
+        self.virtual_networks = {}
+        self.providernet_cache = {}
+        self.interfaces = {}
+        self.stale_interfaces = set()
+        self.deferred_ports = collections.defaultdict(dict)
+        self.phys_ports = {}
+        self.router_interfaces = {}
+        self.metering_timestamp = 0
+        self.stale_ports = {}
+        self.updated_ports = set()
+
+    def notify_mainloop(self):
+        self.vif_event.set()
+        eventlet.greenthread.sleep(0)  # yield
+
+    def vif_created(self, vif_id):
+        LOG.debug("VIF created with uuid={}".format(vif_id))
+        self.notify_mainloop()
+
+    def vif_deleted(self, vif_id):
+        LOG.debug("VIF deleted with uuid={}".format(vif_id))
+        self.notify_mainloop()
+
+    def vif_error_handler(self, exception):
+        LOG.exception("VIF listener exception {}".format(exception))
+
+    def setup_vif_listener(self):
+        self.vif_event = threading.Event()
+        self.vif_listener = vif_api.VifAgentListener(self)
+
+    def rpc_consumers(self):
+        return [[topics.HOST, topics.UPDATE, self.host],
+                [topics.PORT, topics.UPDATE],
+                [topics.NETWORK, topics.DELETE],
+                [topics.SUBNET, topics.CREATE],
+                [topics.SUBNET, topics.DELETE]]
+
+    def setup_rpc(self):
+        self.agent_id = '%s-%s' % ('avs', socket.gethostname())
+        LOG.debug("RPC agent_id: %s", self.agent_id)
+        self.topic = topics.AGENT
+        self.plugin_rpc = agent_rpc.PluginApi(topics.PLUGIN)
+        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)
+        # RPC network init
+        self.context = context.get_admin_context_without_session()
+        # Handle updates from service
+        self.endpoints = [self]
+        self.connection = agent_rpc.create_consumers(self.endpoints,
+                                                     self.topic,
+                                                     self.rpc_consumers())
+        report_interval = cfg.CONF.AGENT.report_interval
+        if report_interval:
+            heartbeat = loopingcall.FixedIntervalLoopingCall(
+                self._report_agent_state)
+            heartbeat.start(interval=report_interval)
+
+    def get_vif_port_by_id(self, port_id):
+        """
+        Retrieve the virtual interface port by id (if it exists)
+        """
+        if port_id in self.virtual_ports:
+            return self.virtual_ports.get(port_id)
+        else:
+            return None
+
+    def _query_host_state(self):
+        if cfg.CONF.AVS.managed_host_state:
+            data = self.plugin_rpc.get_host_details(self.context,
+                                                    self.host,
+                                                    self.agent_id)
+            self.host_state_up = data['host_state_up']
+        else:
+            self.host_state_up = True
+        LOG.info("host_state_up={} on startup".format(self.host_state_up))
+
+    def _report_agent_state(self):
+        try:
+            count = self.vswitch_mgr.get_virtual_port_count()
+            self.agent_state.get('configurations')['devices'] = count
+            self.state_rpc.report_state(self.context, self.agent_state)
+            self.agent_state.pop('start_flag', None)
+        except Exception as e:
+            LOG.exception("Failed to report state, {}".format(e))
+        try:
+            if self.host_state_up is None:
+                self._query_host_state()
+        except Exception as e:
+            LOG.exception("Failed to query state, {}".format(e))
+
+    def _is_agent_enabled(self):
+        return self.admin_state_up is True and self.host_state_up is True
+
+    @staticmethod
+    def _is_port_up(port):
+        """
+        Determine if a port's state should be reported to the plugin as up or
+        down.  This function only considers the admin state of the port since
+        this is an indication that the agent has attached the port to its
+        network and finally it has unlocked the port.  The reason why the link
+        state is not taken in to consideration is that for AVP port types the
+        VM must be up and running (i.e., not paused) for the link state to
+        change.  In Juno, Nova will not unpause the VM until the port status
+        is reported by the Neutron server as an indication of that the VIF
+        "plug" operation has succeeded.
+        """
+        admin_state = getattr(port, 'admin-state')
+        if admin_state == avs_constants.VSWITCH_ADMIN_STATE_DOWN:
+            return False
+        return True
+
+    def is_port_present(self, port_uuid):
+        """
+        Determine if a port is present in the vswitch.  Base this on the
+        virtual device caches rather than querying the vswitch everytime we
+        need to check this information.
+        """
+        virtual_devices = (self.virtual_ports.keys() + self.interfaces.keys())
+        return bool(port_uuid in virtual_devices)
+
+    @staticmethod
+    def _get_device_name(uuid):
+        """
+        Format a fake tap name as:  tap<uuid[0:11]>.
+        """
+        return LB_PORT_NAME_PREFIX + uuid[:LB_PORT_UUID_TAP_LEN]
+
+    def _get_port_tenant_id(self, uuid):
+        if uuid in self.port_details:
+            return getattr(self.port_details[uuid], 'tenant_id', None)
+        else:
+            return None
+
+    def _get_port_network_id(self, uuid):
+        if uuid in self.port_details:
+            return getattr(self.port_details[uuid], 'network_id', None)
+        else:
+            return None
+
+    def _get_port_link_speed(self, uuid):
+        if uuid in self.phys_ports:
+            return getattr(self.phys_ports[uuid], 'link-speed', None)
+        else:
+            return None
+
+    def _get_interface_tenant_id(self, uuid):
+        if uuid in self.interface_details:
+            if_details = self.interface_details[uuid]
+            return if_details['tenant_id']
+        else:
+            return None
+
+    def _get_interface_network_id(self, uuid):
+        if uuid in self.interface_details:
+            if_details = self.interface_details[uuid]
+            return if_details['network_id']
+        else:
+            return None
+
+    def _report_port_state(self, port):
+        """
+        Report current port state to the plugin
+        """
+        port_uuid = port['uuid']
+        if 'local-state' not in port:
+            port['local-state'] = self._is_port_up(port)
+        LOG.debug("Reporting port state {} for port {}".format(
+            port['local-state'], port_uuid))
+        device_name = self._get_device_name(port_uuid)
+        if port['local-state']:
+            self.plugin_rpc.update_device_up(
+                self.context, device_name, self.agent_id, cfg.CONF.host)
+        else:
+            self.plugin_rpc.update_device_down(
+                self.context, device_name, self.agent_id, cfg.CONF.host)
+
+    def _port_should_be_deleted(self, count):
+        """
+        Determine if the 'stale' count exceeds the allowed threshold
+        """
+        threshold = (avs_constants.VSWITCH_STALE_PORT_THRESHOLD_MINS * 60 /
+                     self.polling_interval)
+        return count >= threshold
+
+    def _handle_stale_port(self, uuid, ports):
+        """
+        Handle ports that are present in the vswitch but not in the neutron DB
+        """
+        ports.pop(uuid, None)
+        self.stale_ports[uuid] = self.stale_ports.get(uuid, 0) + 1
+        if not cfg.CONF.AVS.remove_stale_ports:
+            if self.stale_ports[uuid] == 1:
+                LOG.error("Port {} not in DB; "
+                          "stale port audit disabled".format(uuid))
+        elif self._port_should_be_deleted(self.stale_ports[uuid]):
+            LOG.error("Deleting port {} after being "
+                      "missing from DB for {} minutes".format(
+                          uuid,
+                          avs_constants.VSWITCH_STALE_PORT_THRESHOLD_MINS))
+            self.vswitch_mgr.destroy_port(uuid)
+            self.stale_ports.pop(uuid, None)
+        elif self.stale_ports[uuid] == 1:
+            LOG.error("Port {} not in DB; removing in {} minutes".format(
+                uuid, avs_constants.VSWITCH_STALE_PORT_THRESHOLD_MINS))
+
+    def _extend_port_vxlan_details(self, port_details, provider_details):
+        if provider_details:
+            vxlan = copy.deepcopy(provider_details['vxlan'])
+            port_details['vxlan'] = vxlan
+        else:
+            # Build the same info based on the defaults stored locally
+            port_details['vxlan'] = {'group': cfg.CONF.VXLAN.default_group,
+                                     'port': cfg.CONF.VXLAN.default_port,
+                                     'ttl': cfg.CONF.VXLAN.default_ttl}
+
+    @staticmethod
+    def get_providernet_key(segment):
+        """Build a dict key for a given providernet segment."""
+        if segment:
+            return "%s-%s-%s" % (segment['network_type'],
+                                 segment['physical_network'],
+                                 segment['segmentation_id'])
+        return None
+
+    def _extend_port_details(self, port_details):
+        """
+        Some features depend on extensions in the neutron-server.  If the
+        neutron server implementation is an unmodified openstack version then
+        we need to extend the port detail attributes with values from our
+        local configuration.
+        """
+        # This config option is used to determine whether the server supports
+        # this RPC function or not.  The alternative, trying to invoke this
+        # to find out, will end up generating logs on the server.
+        if cfg.CONF.AVS.managed_providers:
+            providernet_key = self.get_providernet_key(port_details)
+            provider_details = self.providernet_cache.get(providernet_key, {})
+            if not provider_details:
+                provider_details = self.plugin_rpc.get_provider_details(
+                    self.context, self.host, self.agent_id,
+                    port_details['network_type'],
+                    port_details['physical_network'],
+                    port_details['segmentation_id'])
+                self.providernet_cache[providernet_key] = provider_details
+        else:
+            provider_details = {}
+
+        # Extend with common fields
+        port_details[wrs_provider.MTU] = provider_details.get('mtu')
+
+        if port_details['network_type'] == n_const.PROVIDERNET_VXLAN:
+            # Extend with VXLAN specific fields
+            self._extend_port_vxlan_details(port_details, provider_details)
+
+    def get_subnets_by_vlan(self, port_details):
+        """
+        Reorganize the list of subnets by vlan id
+        """
+        subnets = port_details.get('subnets', [])
+        device_owner = port_details['device_owner']
+        if not is_vlan_capable_port(device_owner):
+            # Only VM ports get attached to all possible subnets; other types
+            # (e.g., DHCP) get attached only to those subnets for which they
+            # have an IP address.
+            fixed_ips = port_details.get('fixed_ips', [])
+        else:
+            fixed_ips = None
+        vlan_subnets = collections.defaultdict(list)
+        fixed_subnet_ids = [ip['subnet_id'] for ip in fixed_ips or []]
+        for s in subnets:
+            vlan_id = s['subnet'].get('vlan_id', 0)
+            if fixed_ips is None or s['subnet']['id'] in fixed_subnet_ids:
+                vlan_subnets[vlan_id].append(s)
+        return collections.OrderedDict(sorted(vlan_subnets.items()))
+
+    def _get_network_info(self, port_details, vlan_id):
+        """
+        Determine which network this port should be attached to.  The normal
+        case is that the network is specified by the neutron server based on
+        which tenant network the device was attached to.
+        """
+        network = port_details.get('network')
+        network_name = self.vswitch_mgr.get_network_name(
+            network['id'], vlan_id=vlan_id)
+        network_uuid = self.vswitch_mgr.get_network_uuid(
+            network['id'], vlan_id=vlan_id)
+        return network_uuid, network_name
+
+    def _get_provider_mapping(self, physical_network):
+        return self.interface_mappings[physical_network]
+
+    def _setup_network(self, network_uuid, network_name, details):
+        network = {
+            'name': network_name,
+            'network_type': details['network_type'],
+            'physical_network': details['physical_network'],
+            'segmentation_id': details['segmentation_id'],
+            'vlan_transparent': details['network'].get('vlan_transparent'),
+            'vxlan': details.get('vxlan', {}),
+            'mtu': details[wrs_provider.MTU]}
+        provider_uuid, nw_instance = self.vswitch_mgr.setup_network(
+            network_uuid, network)
+        self.interface_details[provider_uuid] = {
+            'network_id': details['network_id'],
+            'tenant_id': details['tenant_id']}
+        self.virtual_networks[network_uuid] = nw_instance
+
+    def setup_interface(self, port, details, vlan_id=None):
+        port_uuid = port['uuid']
+        device_owner = details['device_owner']
+        LOG.debug("setup_interface for {} vlan {} with details {}".format(
+            port_uuid, vlan_id, details))
+
+        # Extend port details with extra attributes if they are not provided
+        # by the neutron server implementation
+        self._extend_port_details(details)
+
+        # Setup the network segment
+        network_uuid, network_name = self._get_network_info(details, vlan_id)
+        if self.manage_network_for_device(details):
+            self._setup_network(network_uuid, network_name, details)
+        else:
+            # The network will be created external to this process so wait for
+            # it.  This is the case in SDN where the controller may create some
+            # networks depending on what mode it is running in.
+            instance = self.virtual_networks.get(network_uuid)
+            if not instance:
+                data = {'port': port, 'details': details}
+                self.deferred_ports[network_uuid][port_uuid] = data
+                LOG.warning("Deferring setup of {} port {} "
+                            "due to missing network {} ({})".format(
+                                device_owner, port_uuid,
+                                network_name, network_uuid))
+                return
+
+        if not is_vlan_capable_port(device_owner):
+            # Only VM ports require a VLAN interface; other types (e.g., DHCP)
+            # get attached directly to the VLAN network from their port
+            # interface.
+            vlan_id = 0
+
+        # Setup the tenant interface
+        if port_uuid == details['port_id']:
+            iface_uuid = self.vswitch_mgr.get_interface_uuid(
+                port_uuid, vlan_id=vlan_id)
+        else:
+            iface_uuid = details['port_id']  # subport
+        instance = self.interfaces.get(iface_uuid)
+        if not instance and vlan_id:
+            self.vswitch_mgr.add_vlan_interface(
+                iface_uuid, vlan_id,
+                details['network'].get('mtu'), port_uuid)
+
+        # Attach the interface to the network segment
+        if not instance or not getattr(instance, 'network-uuid', None):
+            self.vswitch_mgr.attach_interface(iface_uuid, network_uuid)
+
+        # Track the ownership of this interface of stats collection
+        self.interface_details[iface_uuid] = {
+            'network_id': details['network_id'],
+            'tenant_id': details['tenant_id']}
+
+        # TODO(alegacy): Move DVR attributes to AVR if possible
+        if device_owner == constants.DEVICE_OWNER_DVR_INTERFACE:
+            self.bind_dvr_router_interface(iface_uuid, details)
+        else:
+            self.bind_dvr_interface(iface_uuid, details)
+
+        # Add static layer2 table entry for DVR routers
+        if device_owner == constants.DEVICE_OWNER_DVR_INTERFACE:
+            mac_address = details['mac_address']
+            self.vswitch_mgr.add_network_entry(iface_uuid, mac_address)
+
+        return iface_uuid
+
+    def mark_port_for_refresh(self, port_uuid):
+        """
+        Mark a port to be updated with updated DB data.
+        """
+        port_details = self.port_details.get(port_uuid)
+        if port_details:
+            LOG.debug("forcing update of port {}".format(port_uuid))
+            port_details['_updated'] = True
+            self.updated_ports.add(port_uuid)
+
+    def get_port_details(self, port_uuid):
+        """
+        Retrieve the port detail info.  This references cached data if it
+        exists rather than accessing the DB unnecessary.  If the port is marked
+        as updated by an RPC call from the server then the data is refreshed.
+        """
+        port_details = self.port_details.get(port_uuid)
+        if not port_details or port_details.get('_updated', False):
+            port_details = self.plugin_rpc.get_device_details(
+                self.context, port_uuid, self.agent_id, self.host)
+            if not port_details or len(port_details) == 1:
+                self.port_details.pop(port_uuid, None)
+                return None
+            LOG.debug("get_port_details for {} details {}".format(
+                port_uuid, port_details))
+            self.port_details[port_uuid] = port_details
+        return port_details
+
+    def get_ports_on_dvr_subnet(self, subnet_uuid, vlan_id=None):
+        """This is a replacement for get_ports_on_host_by_subnet() that looks
+        at local data instead of needing to invoke a server RPC. Since the
+        vlan-transparent feature was enabled the port details include the
+        network context therefore we can tell which subnets each port is a
+        member of.
+        """
+        ports = set()
+        for port_uuid, details in six.iteritems(self.port_details):
+            fixed_subnet_list = self.get_fixed_subnet_ids(details, vlan_id)
+            if subnet_uuid not in fixed_subnet_list:
+                continue
+            if vlan_id and details['device_owner'].startswith('compute:'):
+                # TODO(alegacy): Remove with guest VLAN subnets
+                interface_uuid = self.vswitch_mgr.get_interface_uuid(
+                    port_uuid, vlan_id)
+                ports.add(interface_uuid)
+            else:
+                ports.add(port_uuid)
+        return ports
+
+    def handle_updated_port(self, port, port_details):
+        """
+        Process a new or updated ports.  The intent of this method is to attach
+        the port's ethernet interface to the appropriate network.  The network
+        is created if it does not already exist.  The network is attached to
+        the appropriate provider network if it is not already attached.  If the
+        port has any VLAN interfaces then they are created here in the same way
+        that the base ethernet interface is created.
+        """
+        port_uuid = port['uuid']
+        device_owner = port_details['device_owner']
+        vlans = set()
+        LOG.debug("handle_updated_port for {}".format(port_uuid))
+
+        # Lock the port immediately if it is in the incorrect state
+        if not port_details['admin_state_up'] and port['admin-state'] == "up":
+            self.vswitch_mgr.lock_port(port_uuid)
+            port['admin-state'] = "down"  # update cached state
+
+        if is_vlan_capable_port(device_owner):
+            # Setup the untagged interface
+            self.setup_interface(port, port_details)
+
+        # Setup the port for any VLAN subnets.
+        # TODO(alegacy): when VLAN subnets are no longer supported this can go
+        # back to being a simple call to setup_interface()
+        vlan_subnets = self.get_subnets_by_vlan(port_details)
+        for vlan_id, subnets in six.iteritems(vlan_subnets):
+            if is_vlan_capable_port(device_owner) and not vlan_id:
+                continue  # already handled in the first setup_interface
+            details = copy.deepcopy(port_details)
+            details.update(subnets[0])
+            details['subnets'] = subnets
+            vlans.add(self.setup_interface(port, details, vlan_id=vlan_id))
+
+        if port_uuid in self.interfaces:
+            # Remove any stale VLANs from pre-existing interfaces
+            existing = set(getattr(self.interfaces[port_uuid], 'vlans', []))
+            self.stale_interfaces |= (existing - vlans)
+
+        # Configure QoS policy information
+        self.update_qos_port_details(port_uuid, port_details)
+
+        # Only unlock the port once it is attached to its network
+        if port_details['admin_state_up'] and port['admin-state'] == "down":
+            self.vswitch_mgr.unlock_port(port_uuid)
+            port['admin-state'] = "up"  # update cached state
+
+    def prepare_sg_device_filters(self, devices):
+        # Base class ignores this type; only handled by default AVS agent
+        return
+
+    def remove_sg_device_filters(self, devices):
+        # Base class ignores this type; only handled by default AVS agent
+        return
+
+    def bind_dvr_router_interface(self, interface_uuid, port_details):
+        # Base class ignores this type; only handled by default AVS agent
+        return
+
+    def bind_dvr_interface(self, interface_uuid, port_details):
+        # Base class ignores this type; only handled by default AVS agent
+        return
+
+    def update_qos_port_details(self, port_uuid, port_details):
+        # Base class ignores this type; only handled by default AVS agent
+        return
+
+    def handle_updated_ports(self, uuids, ports):
+        """
+        Handle ports that were detected to have been added/updated to the
+        vswitch since our last scan.
+        """
+        if not uuids:
+            return
+        # Reduce the list of ports down to those that need to be handled
+        # while maintaining the original order.
+        updated_ports = [x for x in ports.keys() if x in uuids]
+        LOG.debug("{} ports(s) updated: {} ".format(
+            len(updated_ports), updated_ports))
+        devices = [self._get_device_name(uuid) for uuid in updated_ports]
+        self.prepare_sg_device_filters(devices)
+        for uuid in updated_ports:
+            try:
+                port_details = self.get_port_details(uuid)
+                if port_details:
+                    self.handle_updated_port(ports[uuid], port_details)
+                    self._report_port_state(ports[uuid])
+                    self._report_trunk_state(ports[uuid])
+                else:
+                    self._handle_stale_port(uuid, ports)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+
+    def check_orphaned_networks(self, port_uuid, network_ids):
+        """
+        Given a list of network_ids check to ensure that none of them are
+        orphaned as a result of deleting the port specified by the port_uuid
+        parameter.  Interfaces that are currently being used by a provider
+        network connectivity test are preserved so that ongoing tests are not
+        interrupted.
+        """
+        in_use_interfaces = self._pnet_connectivity_interface_uuids()
+        # Delete any that are now orphaned
+        for network_id in network_ids:
+            if not self.vswitch_mgr.is_network_orphaned(network_id):
+                continue
+            LOG.warning("Last port {} deleted; deleting network {}".format(
+                        port_uuid, network_id))
+            self.vswitch_mgr.delete_network(network_id, in_use_interfaces)
+            self.virtual_networks.pop(network_id, None)
+            for uuid, iface in self.interface_details.items():
+                if iface['network_id'] == network_id:
+                    self.interface_details.pop(uuid, None)
+
+    def handle_removed_port(self, port_uuid):
+        """
+        Handle the deletion of a port
+        """
+        self.interface_details.pop(port_uuid, None)
+        port_details = self.port_details.pop(port_uuid, None)
+        if not port_details:
+            LOG.warning("Previously unknown port {} removed".format(
+                port_uuid))
+            return
+        if not self.manage_network_for_device(port_details):
+            # Leave the network(s) as-is if we are not managing them.
+            return
+
+        network_ids = set()
+        # Handle vlan subnets first.
+        # TODO(alegacy): when vlan subnets are no longer supported this can be
+        # replaced with the network_id in the port_details.
+        vlan_subnets = self.get_subnets_by_vlan(port_details)
+        for vlan_id, subnets in six.iteritems(vlan_subnets):
+            network_uuid, _ = self._get_network_info(port_details, vlan_id)
+            network_ids.add(network_uuid)
+
+        # Prune the list of networks down to those that still exist
+        current_networks = self.virtual_networks
+        network_ids &= set(current_networks)
+        self.check_orphaned_networks(port_uuid, network_ids)
+
+    def handle_removed_ports(self, uuids, ports):
+        """
+        Handle ports that were detected to have been removed from the vswitch
+        since our last scan.
+        """
+        if not uuids:
+            return
+        LOG.debug("{} port(s) removed: {} ".format(len(uuids), uuids))
+        devices = [self._get_device_name(uuid) for uuid in uuids]
+        self.remove_sg_device_filters(devices)
+        for uuid in uuids:
+            try:
+                self.plugin_rpc.update_device_down(
+                    self.context, self._get_device_name(uuid), self.agent_id,
+                    cfg.CONF.host)
+                self.handle_removed_port(uuid)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+
+    def compare_ports(self, uuids, current, previous):
+        """
+        Compare existing ports to determine if a state change needs to be
+        reported to the plugin or if any port needs to be reconfigured.
+        """
+        updated = self.updated_ports & set(uuids)
+        self.updated_ports = set()
+        for uuid in uuids:
+            try:
+                new = current[uuid]
+                old = previous[uuid]
+                new['local-state'] = self._is_port_up(new)
+                if (new['created-timestamp'] != old['created-timestamp']):
+                    # The object has been deleted and re-added therefore we
+                    # need to add this to the list of ports that we need to
+                    # reconfigure.
+                    LOG.warning("port {} create timestamp changed;"
+                                "reconfiguring".format(uuid))
+                    updated.add(uuid)
+                elif (('local-state' not in old) or
+                        (new['local-state'] != old['local-state'])):
+                    # The local state has changed so inform the server
+                    self._report_port_state(new)
+                elif uuid in self.updated_ports:
+                    # The server state has changed so report our current local
+                    # port status back up to it.
+                    self._report_port_state(new)
+                self.updated_ports.discard(uuid)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+        self.handle_updated_ports(updated, current)
+
+    def _process_virtual_ports(self, current_ports, previous_ports):
+        """
+        Process the list of ports to determine if ports have been added,
+        removed, or modified.
+        """
+        current = set(current_ports.keys())
+        previous = set(previous_ports.keys())
+        added = current - previous
+        removed = previous - current
+        existing = current & previous
+        self.handle_updated_ports(added, current_ports)
+        self.handle_removed_ports(removed, previous_ports)
+        self.compare_ports(existing, current_ports, previous_ports)
+
+    def _virtual_ports_loop(self):
+        """
+        Retrieve the current list of virtual ports and compare against the
+        expected list of ports, updating accordingly
+        """
+        try:
+            # audit the virtual ports
+            previous = self.virtual_ports
+            self.virtual_ports = self.vswitch_mgr.get_virtual_port_list()
+            self._process_virtual_ports(self.virtual_ports, previous)
+        except Exception as e:
+            # Clear the device list and resync with the plugin
+            LOG.exception("Failed to process virtual "
+                          "port list, {}".format(e))
+            self.virtual_ports = {}
+
+    def handle_updated_interface(self, interface_uuid, port_details):
+        """
+        Process a new router interface attaching it to a network if necessary
+        """
+        # TODO(alegacy): when VLAN subnets are no longer supported this can go
+        # back to being a simple call to setup_interface()
+        vlan_subnets = self.get_subnets_by_vlan(port_details)
+        assert(len(vlan_subnets) == 1)
+
+        for vlan_id, subnets in six.iteritems(vlan_subnets):
+            details = copy.deepcopy(port_details)
+            details.update(subnets[0])
+            details['subnets'] = subnets
+            self.setup_interface(interface_uuid, details, vlan_id=vlan_id)
+
+    def handle_removed_interface(self, port_uuid):
+        """
+        Handle the deletion of a router interface
+        """
+        # The delete operation is the same for ports and interfaces
+        self.handle_removed_port(port_uuid)
+
+    def handle_updated_interfaces(self, uuids, interfaces):
+        """
+        Handle interfaces that were detected to have been added/updated to the
+        vswitch since our last scan.
+        """
+        # Reduce the list of interfaces down to those that need to be handled
+        # while maintaining the original order.
+        updated_interfaces = [x for x in interfaces.keys() if x in uuids]
+        LOG.debug("{} interface(s) updated: {} ".format(
+            len(updated_interfaces), updated_interfaces))
+        for uuid in updated_interfaces:
+            try:
+                port_details = self.get_port_details(uuid)
+                if not port_details:
+                    continue  # not present in DB
+                self.handle_updated_interface(interfaces[uuid], port_details)
+                self.plugin_rpc.update_device_up(
+                    self.context, self._get_device_name(uuid),
+                    self.agent_id, cfg.CONF.host)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+
+    def handle_removed_interfaces(self, uuids):
+        """
+        Handle interfaces that were detected to have been removed from the
+        vswitch since our last scan.
+        """
+        for uuid in uuids:
+            try:
+                self.plugin_rpc.update_device_down(
+                    self.context, self._get_device_name(uuid), self.agent_id,
+                    cfg.CONF.host)
+                self.handle_removed_interface(uuid)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+
+    def compare_interfaces(self, uuids, current, previous):
+        """
+        Compare existing interfaces to determine if a state change needs to be
+        reported to the plugin or if any interface needs to be reconfigured.
+        """
+        updated = set()
+        for uuid in uuids:
+            try:
+                new = current[uuid]
+                old = previous[uuid]
+                if (new['created-timestamp'] != old['created-timestamp']):
+                    # The object has been deleted and re-added therefore we
+                    # need to add this to the list of ports that we need to
+                    # reconfigure.
+                    LOG.warning("router interface {} create timestamp "
+                                "changed; reconfiguring".format(uuid))
+                    updated.add(uuid)
+            except manager.VSwitchManagerError as e:
+                LOG.exception(repr(e))
+        self.handle_updated_interfaces(updated, current)
+
+    def _process_router_interfaces(self,
+                                   current_interfaces, previous_interfaces):
+        """
+        Process the list of ports to determine if ports have been added,
+        removed, or modified.
+        """
+        current = set(current_interfaces.keys())
+        previous = set(previous_interfaces.keys())
+        added = current - previous
+        removed = previous - current
+        existing = current & previous
+        self.handle_updated_interfaces(added, current_interfaces)
+        self.handle_removed_interfaces(removed)
+        self.compare_interfaces(
+            existing, current_interfaces, previous_interfaces)
+
+    def _router_interfaces_loop(self):
+        """
+        Retrieve the current list of router interfaces and compare against the
+        current list of ports, updating accordingly
+        """
+        try:
+            previous = self.router_interfaces
+            self.router_interfaces = (
+                self.vswitch_mgr.get_router_interface_list(
+                    interfaces=self.interfaces))
+            self._process_router_interfaces(self.router_interfaces, previous)
+        except Exception as e:
+            # Clear the interface list and resync with the plugin
+            LOG.exception("Failed to process router "
+                          "interface list, {}".format(e))
+            self.router_interfaces = {}
+
+    def _interfaces_loop(self):
+        """
+        Retrieve the current list of interfaces and cache the list for later
+        operations to reduce the number of API calls to AVS.
+        """
+        try:
+            self.interfaces = self.vswitch_mgr.get_interface_list()
+        except Exception as e:
+            # Clear the interface list and resync with the plugin
+            LOG.exception("Failed to cache interface list, {}".format(e))
+
+    def _report_port_state_fault(self, port):
+        """
+        Generate a fault management alarm condition for link state fault
+        """
+        LOG.debug("Report link state fault: {}".format(port['uuid']))
+        self.fm_driver.report_port_state_fault(self.host, port['uuid'],
+                                               fm.FM_SEVERITY_MAJOR)
+
+    def _clear_port_state_fault(self, port):
+        """
+        Clear a fault management alarm condition for link state fault
+        """
+        LOG.debug("Clear link state fault: {}".format(port['uuid']))
+        self.fm_driver.clear_port_state_fault(self.host, port['uuid'])
+
+    def _get_port_state_faults(self):
+        """
+        Get the current list of port faults
+        """
+        faults = self.fm_driver.get_port_state_faults(self.host)
+        return faults or []
+
+    def _report_interface_state_fault(self, interface, severity):
+        """
+        Generate a fault management alarm condition for interface state fault
+        """
+        LOG.debug("Report interface state fault: {}".format(interface['uuid']))
+        self.fm_driver.report_interface_state_fault(self.host,
+                                                    interface['uuid'],
+                                                    severity)
+
+    def _clear_interface_state_fault(self, interface):
+        """
+        Clear a fault management alarm condition for interface state fault
+        """
+        LOG.debug("Clear interface state fault: {}".format(interface['uuid']))
+        self.fm_driver.clear_interface_state_fault(self.host,
+                                                   interface['uuid'])
+
+    def _get_interface_state_faults(self):
+        """
+        Get the current list of interface faults
+        """
+        faults = self.fm_driver.get_interface_state_faults(self.host)
+        return faults or []
+
+    def _collect_engine_statistics(self, timestamp):
+        """
+        Retrieve the current engine statistics and reports it
+        through the notification API for the metering listener
+        to consume
+        """
+
+        engine_metrics = []
+        engine_stats = self.vswitch_mgr.get_engine_stats()
+        for stats in engine_stats:
+            data = stats.to_dict()
+            cycles_total = (float(stats['cycles-busy']) +
+                            float(stats['cycles-idle']))
+            if cycles_total:
+                cpu_util = float(stats['cycles-busy']) / cycles_total * 100
+            else:
+                cpu_util = 0
+
+            data['timestamp'] = timestamp
+            data['host'] = self.host
+            data['cpu_id'] = stats['cpuid']
+            data['cpu_util'] = cpu_util
+            data['rx_discard'] = stats['rx-discard-priority']
+            data['tx_discard'] = (long(stats['tx-discard']) +
+                                  long(stats['tx-timeout']) +
+                                  long(stats['tx-discard-priority']) +
+                                  long(stats['tx-discard-provider']))
+
+            engine_metrics.append(data)
+
+        self._notifier.info(self.context, 'vswitch.meter.engine',
+                            {'engine-metrics': engine_metrics})
+
+    @staticmethod
+    def _ethernet_frame_overhead(link_speed):
+        """
+        Return the packet framing overhead based on link speed (speed in
+        megabits/second)
+        """
+        if link_speed == 40000 or link_speed == 100000:
+            gap = 1
+        elif link_speed == 10000:
+            gap = 5
+        elif link_speed == 1000:
+            gap = 8
+        else:
+            gap = 12
+
+        # 24 bytes overhead per packet/frame (1-12 gap, 8 preamble, 4 crc)
+        return gap + 8 + 4
+
+    def _compute_port_utilisation(self, byte_count, packet_count,
+                                  duration, link_speed):
+        """
+        Calculates the port link utilisation given the current data rate
+        and speed.
+        byte_count - packet byte count in period
+        packet_count - packet count in period
+        duration - period in seconds
+        link_speed - link speed in megabits/second
+        """
+        if not packet_count:
+            return 0
+
+        ether_overhead = self._ethernet_frame_overhead(link_speed)
+        packet_overhead = packet_count * ether_overhead
+
+        if duration and link_speed:
+            data_rate = float(byte_count + packet_overhead) / float(duration)
+            port_util = (float(data_rate) /
+                         (float((link_speed * 1000 * 1000) / 8))) * 100
+            return port_util
+        else:
+            return 0
+
+    def _collect_port_statistics(self, timestamp):
+        """
+        Retrieves the current port statistics and reports it
+        through the notification API for the metering listener
+        to consume
+        """
+        duration = timestamp - self.metering_timestamp
+
+        # retrieve physical port list to obtain port link-speed
+        self.phys_ports = self.vswitch_mgr.get_physical_port_list()
+
+        port_metrics = []
+        port_stats = self.vswitch_mgr.get_port_stats()
+        for stats in port_stats:
+            data = stats.to_dict()
+            uuid = stats['uuid']
+            data['timestamp'] = timestamp
+            data['host'] = self.host
+            data['tenant_id'] = self._get_port_tenant_id(uuid)
+            data['network_id'] = self._get_port_network_id(uuid)
+            data['link-speed'] = self._get_port_link_speed(uuid)
+
+            # compute link utilisation if possible
+            prev = self.port_stats.get(uuid, None)
+            if prev and data['link-speed']:
+                rx_packets = (long(stats['rx-packets']) -
+                              long(prev['rx-packets']))
+                tx_packets = (long(stats['tx-packets']) -
+                              long(prev['tx-packets']))
+                rx_bytes = (long(stats['rx-bytes']) -
+                            long(prev['rx-bytes']))
+                tx_bytes = (long(stats['tx-bytes']) -
+                            long(prev['tx-bytes']))
+
+                link_speed = data['link-speed']
+
+                data['rx-util'] = self._compute_port_utilisation(
+                    rx_bytes, rx_packets, duration, link_speed)
+                data['tx-util'] = self._compute_port_utilisation(
+                    tx_bytes, tx_packets, duration, link_speed)
+            else:
+                data['rx-util'] = None
+                data['tx-util'] = None
+
+            # save stats for next iteration computation
+            self.port_stats[uuid] = stats
+
+            port_metrics.append(data)
+
+        self._notifier.info(self.context, 'vswitch.meter.port',
+                            {'port-metrics': port_metrics})
+
+    def _collect_interface_statistics(self, timestamp):
+        """
+        Retrieves the current interface statistics and reports it
+        through the notification API for the metering listener
+        to consume
+        """
+
+        interface_metrics = []
+        interface_stats = self.vswitch_mgr.get_interface_stats()
+        for stats in interface_stats:
+            data = stats.to_dict()
+
+            uuid = data['uuid']
+            data['timestamp'] = timestamp
+            data['host'] = self.host
+            data['tenant_id'] = self._get_interface_tenant_id(uuid)
+            data['network_uuid'] = self._get_interface_network_id(uuid)
+
+            interface_metrics.append(data)
+
+        self._notifier.info(self.context, 'vswitch.meter.interface',
+                            {'interface-metrics': interface_metrics})
+
+    def _metering_loop(self):
+        """
+        Retrieve the current vswitch statistics and report it to
+        the metering notification collector.
+        """
+        try:
+            timestamp = int(time.time())
+            delta = timestamp - self.metering_timestamp
+            if delta > self.metering_interval:
+                if self._is_agent_enabled():
+                    self._collect_engine_statistics(timestamp)
+                    self._collect_port_statistics(timestamp)
+                    self._collect_interface_statistics(timestamp)
+                self.metering_timestamp = timestamp
+        except Exception as e:
+            # Collection failed, log error and retry at next interval
+            LOG.exception("Failed to collect metering data, {}".format(e))
+
+    def manage_network_for_device(self, port_details):
+        return True
+
+    def _process_virtual_networks(self, current_networks, previous_networks):
+        # No action required in non-SDN deployments
+        pass
+
+    def _virtual_networks_loop(self):
+        try:
+            # audit the virtual networks
+            previous = self.virtual_networks
+            current = self.vswitch_mgr.get_networks()
+            self._process_virtual_networks(current, previous)
+            self.virtual_networks = current
+        except Exception as e:
+            # Clear the device list and resync with the plugin
+            LOG.exception("Failed to process virtual "
+                          "network list, {}".format(e))
+            self.virtual_networks = {}
+
+    def _delete_interface(self, interface_uuid):
+        instance = self.interfaces[interface_uuid]
+        network_uuid = getattr(instance, 'network-uuid', None)
+        self.vswitch_mgr.delete_interface(interface_uuid)
+        self.check_orphaned_networks(interface_uuid, [network_uuid])
+
+    def _stale_interfaces_loop(self):
+        """
+        Handle any interfaces that were flagged as stale.  These could be any
+        interface in AVS that no longer maps to and actual neutron port but
+        more likely they are VLAN interfaces that map to a neutron port trunk
+        or subport that no longer exists or is administratively disabled.
+        """
+        try:
+            for vlan_uuid in self.stale_interfaces:
+                LOG.warning("Removing VNIC VLAN interface {}\n".format(
+                    vlan_uuid))
+                self._delete_interface(vlan_uuid)
+        except Exception as e:
+            # Clear the device list and resync with the plugin
+            LOG.exception("Failed to process stale "
+                          "interface list, {}".format(e))
+        self.stale_interfaces = set()
+
+    def daemon_loop_body(self):
+        self._virtual_networks_loop()
+        self._interfaces_loop()
+        self._router_interfaces_loop()
+        self._virtual_ports_loop()
+        self._metering_loop()
+        self._stale_interfaces_loop()
+        if self.vif_event.wait(self.polling_interval):
+            self.vif_event.clear()
+
+    def daemon_loop(self):
+        """
+        Scan the vswitch at fixed intervals to determine if ports have been
+        added, removed, or modified and to collect metering data.
+        """
+        LOG.info("vSwitch Agent RPC Daemon Started")
+        while True:
+            self.daemon_loop_body()
+
+
+class VSwitchNeutronAgent(VSwitchBaseNeutronAgent,
+                          VSwitchRpcCallbacksMixin):
+    def __init__(self,
+                 interface_mappings,
+                 polling_interval,
+                 metering_interval,
+                 status_interval,
+                 vswitch_api,
+                 enable_distributed_routing=False):
+        self.dvr_mac_audit_timestamp = 0
+        self.pnet_connectivity_audit_uuid = None
+        self.pnet_connectivity_manager = self
+        self.pnet_connectivity_interfaces = []
+        self.link_local_address = None
+        super(VSwitchNeutronAgent, self).__init__(
+            interface_mappings,
+            polling_interval,
+            metering_interval,
+            status_interval,
+            vswitch_api,
+            enable_distributed_routing)
+        self._remove_unattached_provider_interfaces()
+        self.qos_agent = qos_rpc.QoSAgentRpc(self.context, self.qos_plugin_rpc)
+        self.qos_agent.register_manager(self.vswitch_mgr)
+
+        self.sg_agent = VSwitchSecurityGroupAgentRpc(self.context,
+                                                     self.sg_plugin_rpc)
+        self.sg_agent.register_manager(self.vswitch_mgr)
+
+        self.dvr_agent = dvr.VswitchDVRNeutronAgent(
+            self.context,
+            self.dvr_plugin_rpc,
+            self,
+            self.host,
+            self.enable_distributed_routing)
+
+        self.dvr_agent.register_manager(self.vswitch_mgr)
+
+    def rpc_consumers(self):
+        result = super(VSwitchNeutronAgent, self).rpc_consumers()
+        result.extend([[topics.SECURITY_GROUP, topics.UPDATE],
+                       [topics.QOS, topics.UPDATE],
+                       [topics.DVR, topics.UPDATE],
+                       [topics.PNET_CONNECTIVITY, topics.UPDATE, self.host]])
+        return result
+
+    def setup_rpc(self):
+        self.sg_plugin_rpc = sg_rpc.SecurityGroupServerRpcApi(topics.PLUGIN)
+        self.dvr_plugin_rpc = dvr_rpc.DVRServerRpcApi(topics.PLUGIN)
+        self.qos_plugin_rpc = qos_rpc.QoSServerRpcApi(topics.PLUGIN)
+        return super(VSwitchNeutronAgent, self).setup_rpc()
+
+    def prepare_sg_device_filters(self, devices):
+        super(VSwitchNeutronAgent, self).prepare_sg_device_filters(devices)
+        self.sg_agent.prepare_devices_filter(devices)
+
+    def remove_sg_device_filters(self, devices):
+        super(VSwitchNeutronAgent, self).remove_sg_device_filters(devices)
+        self.sg_agent.remove_devices_filter(devices)
+
+    def bind_dvr_router_interface(self, interface_uuid, port_details):
+        return self.dvr_agent.bind_router_interface_to_dvr(
+            interface_uuid, port_details)
+
+    def bind_dvr_interface(self, interface_uuid, port_details):
+        return self.dvr_agent.bind_interface_to_dvr(
+            interface_uuid, port_details)
+
+    def update_qos_port_details(self, port_uuid, port_details):
+        port_qos_policy = port_details.get('port_qos_policy', None)
+        if port_qos_policy is not None:
+            self.qos_agent.qos.port_qos_updated(port_qos_policy, port_uuid)
+
+        network_qos_policy = port_details.get('network_qos_policy', None)
+        if network_qos_policy is not None:
+            self.qos_agent.qos.network_qos_updated(
+                network_qos_policy, port_details['network_id'])
+
+    def _pnet_connectivity_interface_uuids(self):
+        """
+        Return list of interfaces currently in use for
+        providernet connectivity testing
+        """
+        return [i.interface_uuid for i in self.pnet_connectivity_interfaces]
+
+    def _remove_unattached_provider_interfaces(self, interface_list=None):
+        """Removes all provider interfaces that are lacking a network uuid"""
+        current_interfaces = self.vswitch_mgr.get_interface_list()
+        if interface_list:
+            interface_dict = {uuid: current_interfaces[uuid]
+                              for uuid in interface_list
+                              if uuid in current_interfaces}
+        else:
+            interface_dict = current_interfaces
+        mapped_interface_uuids = self.interface_mappings.values()
+        for interface_uuid, interface in six.iteritems(interface_dict):
+            if interface_uuid in mapped_interface_uuids:
+                continue
+            iftype = interface['type']
+            if (iftype == avs_constants.VSWITCH_VXLAN_INTERFACE or
+                    iftype == avs_constants.VSWITCH_VLAN_INTERFACE):
+                ifclass = interface['class']
+                if ifclass == avs_constants.VSWITCH_PROVIDER_INTERFACE:
+                    if 'network-uuid' not in interface:
+                        self.vswitch_mgr.delete_interface(interface_uuid)
+
+    def _setup_connectivity_audit(self, providernet, segments, extra_data):
+        """Sets up a connectivity audit and return link-local address"""
+        # Determine which logical interface implements this provider network
+        self.pnet_connectivity_interfaces = []
+        providernet_id, providernet_name, providernet_type = providernet
+        lower_uuid = self._get_provider_mapping(providernet_name)
+        lower_interface = self.vswitch_mgr.get_interface(lower_uuid)
+        network = {'network_type': providernet_type,
+                   'physical_network': providernet_name,
+                   'mtu': extra_data[wrs_provider.MTU]}
+        if providernet_type == n_const.PROVIDERNET_VLAN:
+            for segmentation_id in segments:
+                network.update({'segmentation_id': segmentation_id})
+                interface_uuid = self.vswitch_mgr.setup_provider_interface(
+                    lower_uuid, network)
+                segment_iface = VSwitchNetworkSegmentInterface(
+                    providernet_id, providernet_name, providernet_type,
+                    segmentation_id, interface_uuid
+                )
+                self.pnet_connectivity_interfaces.append(segment_iface)
+        elif providernet_type == n_const.PROVIDERNET_VXLAN:
+            for segment in segments:
+                network.update({'segmentation_id': segment['minimum'],
+                                'vxlan': segment['vxlan']})
+                interface_uuid = self.vswitch_mgr.setup_provider_interface(
+                    lower_uuid, network)
+                segment_iface = VSwitchNetworkSegmentInterface(
+                    providernet_id, providernet_name, providernet_type,
+                    segment['id'], interface_uuid
+                )
+                self.pnet_connectivity_interfaces.append(segment_iface)
+        elif providernet_type == n_const.PROVIDERNET_FLAT:
+            interface_uuid = self.vswitch_mgr.setup_provider_interface(
+                lower_uuid, network)
+            segment_iface = VSwitchNetworkSegmentInterface(
+                providernet_id, providernet_name, providernet_type,
+                n_const.PROVIDERNET_FLAT, interface_uuid
+            )
+            self.pnet_connectivity_interfaces.append(segment_iface)
+
+        mac_address = lower_interface['mac-address']
+        self.link_local_address = ipv6_utils.get_link_local_address_by_mac(
+            mac_address
+        )
+        return self.link_local_address
+
+    def _calculate_packet_size_for_ping(self, providernet_mtu):
+        """
+        For a given MTU, return the maximum length for ping,
+        or return default size if no MTU is specified
+        """
+        if providernet_mtu:
+            length = (providernet_mtu -
+                      avs_constants.VSWITCH_IPV6_ICMP_HEADER_SIZE)
+        else:
+            length = avs_constants.VSWITCH_PING_MINIMUM_SIZE
+        return length
+
+    def _test_interface_connectivity_to_address(self, link_local_address,
+                                                interface_uuid, mtu=None):
+        """Returns whether an interface can ping a given address"""
+        # Don't try pinging if address is local
+        if link_local_address == self.link_local_address:
+            return True
+        # Calculate maximum size based on MTU if exists, should be IPv6
+        length = self._calculate_packet_size_for_ping(mtu)
+
+        for i in range(n_const.PROVIDERNET_CONNECTIVITY_TEST_ATTEMPTS):
+            if self.vswitch_mgr.ping(link_local_address,
+                                     interface_uuid, length):
+                return True
+        return False
+
+    def _get_reason_for_failure(self, mtu=None):
+        """Provide a reason a test failed based on the MTU"""
+        if mtu:
+            return "Failed with MTU %s" % str(mtu)
+        return "Failed to ping target"
+
+    def _run_connectivity_tests(self, common_tuple, link_local_address,
+                                extra_data):
+        """
+        Test connectivity to address for all interfaces and return a list
+         of tuples with the results of each test containing:
+         (local_hostname, master_hostname, provdernet_id, segment, state).
+        """
+        mtu = extra_data[wrs_provider.MTU]
+        test_results = []
+        for segment_iface in self.pnet_connectivity_interfaces:
+            segment_details = (segment_iface.providernet_id,
+                               segment_iface.segment)
+
+            if self._test_interface_connectivity_to_address(
+                link_local_address, segment_iface.interface_uuid
+            ):
+                test_result = (
+                    n_const.PROVIDERNET_CONNECTIVITY_PASS,
+                    ""
+                )
+            else:
+                test_result = (
+                    n_const.PROVIDERNET_CONNECTIVITY_FAIL,
+                    self._get_reason_for_failure()
+                )
+                test_results.append(common_tuple + segment_details +
+                                    test_result)
+                continue
+
+            if self._test_interface_connectivity_to_address(
+                link_local_address, segment_iface.interface_uuid, mtu
+            ):
+                test_result = (
+                    n_const.PROVIDERNET_CONNECTIVITY_PASS,
+                    ""
+                )
+            else:
+                test_result = (
+                    n_const.PROVIDERNET_CONNECTIVITY_FAIL,
+                    self._get_reason_for_failure(mtu)
+                )
+                test_results.append(common_tuple + segment_details +
+                                    test_result)
+                continue
+
+            test_results.append(common_tuple + segment_details +
+                                test_result)
+        return test_results
+
+    def _run_connectivity_audit(self, masters, extra_data):
+        """Run tests to a given list of masters"""
+        connectivity_tests_results = []
+        local_hostname = self.host
+        for master_hostname, link_local_address in masters:
+
+            common_tuple = (local_hostname, master_hostname)
+            test_results = self._run_connectivity_tests(common_tuple,
+                                                        link_local_address,
+                                                        extra_data)
+            connectivity_tests_results.extend(test_results)
+        return connectivity_tests_results
+
+    def _teardown_connectivity_audit(self, clearall=False):
+        """Removes interfaces created for the most recent audit"""
+        if clearall:
+            interfaces_to_remove = None
+        else:
+            interfaces_to_remove = [segment_iface.interface_uuid
+                                    for segment_iface in
+                                    self.pnet_connectivity_interfaces]
+        self._remove_unattached_provider_interfaces(interfaces_to_remove)
+        self.pnet_connectivity_interfaces = []
+        return True
+
+    def _start_connectivity_audit(self, audit_uuid, masters, hosts,
+                                  providernet, segments, extra_data):
+        """Setup iff on a slave, run tests, then teardown iff on a slave"""
+        local_hostname = self.host
+        self.pnet_connectivity_audit_uuid = audit_uuid
+        # Only run on specified hosts
+        if local_hostname not in hosts:
+            return
+
+        # get list of master hostnames to use to check if on master
+        master_hostnames = [hostname for hostname, _ in masters]
+
+        # On masters, run separately and wait for response
+        if local_hostname not in master_hostnames:
+            self._setup_connectivity_audit(providernet,
+                                           segments, extra_data)
+
+        # Add a slight delay in case port isn't ready
+        time.sleep(2)
+
+        # Run on all nodes including masters
+        results = self._run_connectivity_audit(masters, extra_data)
+
+        # On masters, run separately and wait for response
+        if local_hostname not in master_hostnames:
+            self._teardown_connectivity_audit()
+
+        # report results at the end of call
+        self._report_connectivity_results(results)
+
+    def _report_connectivity_results(self, results_list):
+        """Use RPC API to contact controller to write results to database"""
+        pass
+
+    def _audit_dvr_mac_addresses(self):
+        """
+        Retrieve the current list of DVR MAC addresses to make sure we have an
+        up to date copy.
+        """
+        try:
+            timestamp = int(time.time())
+            if timestamp >= self.dvr_mac_audit_timestamp:
+                self.dvr_agent.get_peer_dvr_mac_addresses()
+                self.dvr_mac_audit_timestamp = (
+                    timestamp + DVR_MAC_ADDRESS_AUDIT_INTERVAL)
+        except Exception:
+            LOG.exception("Failed to audit peer DVR MAC address list")
+
+    def daemon_loop_body(self):
+        self._audit_dvr_mac_addresses()
+        super(VSwitchNeutronAgent, self).daemon_loop_body()
+
+
+class VSwitchSdnNeutronAgent(VSwitchBaseNeutronAgent,
+                             VSwitchSdnRpcCallbacksMixin):
+
+    def __init__(self,
+                 interface_mappings,
+                 polling_interval,
+                 metering_interval,
+                 status_interval,
+                 vswitch_api,
+                 enable_distributed_routing=False):
+        super(VSwitchSdnNeutronAgent, self).__init__(
+            interface_mappings,
+            polling_interval,
+            metering_interval,
+            status_interval,
+            vswitch_api,
+            enable_distributed_routing)
+
+    def _pnet_connectivity_interface_uuids(self):
+        # Feature not supported in SDN mode so always return an empty list
+        return []
+
+    def _get_network_info(self, port_details, vlan_id=None):
+        """
+        Determine which network this port should be attached to.  The normal
+        case is that the network is specified by the neutron server based on
+        which tenant network the device was attached to.  For SDN there are two
+        cases to consider.  (1) the SDN controller is doing both layer2 and
+        layer3 roles therefore it manages all bridges.  (2) The SDN controller
+        is only doing layer2 in which case we need to manage our own external
+        network bridges.
+        """
+        device_owner = port_details['device_owner']
+        if device_owner in DEVICES_ON_EXTERNAL_NETWORKS:
+            if cfg.CONF.SDN.manage_external_networks:
+                return super(VSwitchSdnNeutronAgent, self)._get_network_info(
+                    port_details, vlan_id=vlan_id)
+            else:
+                network_name = cfg.CONF.SDN.external_bridge_name
+                network_uuid = self.vswitch_mgr.get_openflow_bridge_uuid(
+                    network_name)
+        else:
+            network_name = cfg.CONF.SDN.integration_bridge_name
+            network_uuid = self.vswitch_mgr.get_openflow_bridge_uuid(
+                network_name)
+        return network_uuid, network_name
+
+    def _handle_new_virtual_network(self, network_uuid, network):
+        """
+        Handles the addition of a new tenant network in AVS.  This means that
+        we need to consult our deferred port and router interface list and
+        attach any objects that were waiting for this network.
+        """
+        # Attach all deferred ports
+        ports = copy.deepcopy(self.deferred_ports[network_uuid])
+        for port_uuid, data in six.iteritems(ports):
+            port_details = data['details']
+            device_owner = port_details['device_owner']
+            if is_avs_port(device_owner):
+                self.handle_updated_port(data['port'], port_details)
+            else:
+                self.handle_updated_interface(data['port'], port_details)
+            del self.deferred_ports[network_uuid][port_uuid]
+
+    def _process_virtual_networks(self, current_networks, previous_networks):
+        """
+        Process the list of virtual networks and handle any networks that were
+        added while we were waiting.   This should only ever pick up networks
+        that are created by the SDN controller (br-int, br-ex).
+        """
+        current = set(current_networks)
+        previous = set(previous_networks)
+        added = current - previous
+        for network_uuid in added:
+            network = current_networks[network_uuid]
+            self._handle_new_virtual_network(network_uuid, network)
+        return current_networks
+
+    def manage_network_for_device(self, port_details):
+        device_owner = port_details['device_owner']
+        if device_owner in DEVICES_ON_EXTERNAL_NETWORKS:
+            return cfg.CONF.SDN.manage_external_networks
+        return False
+
+    def handle_removed_port(self, uuid, port_details):
+        # Run default/base actions to delete the port
+        super(VSwitchSdnNeutronAgent, self).handle_removed_port(
+            uuid, port_details)
+        # Check whether we were waiting for a network to appear for this port
+        # or interface object.
+        for network_uuid in self.deferred_ports.keys():
+            ports = copy.deepcopy(self.deferred_ports[network_uuid])
+            for port_uuid, data in six.iteritems(ports):
+                if port_uuid == uuid:
+                    del self.deferred_ports[network_uuid][port_uuid]
+        return
+
+
+def _parse_physical_interface_mappings(mapping_list):
+    """Parse configuration physical_interface_mappings parameter"""
+    mappings = {}
+    for mapping in mapping_list:
+        # split in to key=value pair
+        uuid_str, networks = mapping.split('=')
+        if not uuid_str or not networks:
+            msg = "Failed to parse key=value pair \'{}\'".format(mapping)
+            LOG.error(msg)
+            raise ValueError(msg)
+        # Validate that the string is a valid UUID
+        uuidutils.is_uuid_like(uuid_str)
+        # Parse out the list of provider networks assigned to the UUID
+        for network in networks.split(':'):
+            if network in mappings:
+                msg = "Provider network {} already mapped to {}".format(
+                      network, mappings[network])
+                LOG.error(msg)
+                raise ValueError(msg)
+            mappings.update({network: uuid_str})
+    return mappings
+
+
+def _register_opts(conf):
+    conf.register_opts(avs_opts, "AVS")
+    conf.register_opts(agent_opts, "AGENT")
+    conf.register_opts(vxlan_opts, "VXLAN")
+    conf.register_opts(sdn_opts, "SDN")
+    config.register_agent_state_opts_helper(conf)
+    config.register_availability_zone_opts_helper(conf)
+    config.register_root_helper(conf)
+
+
+def main():
+    _register_opts(cfg.CONF)
+    common_config.init(sys.argv[1:])
+    common_config.setup_logging()
+
+    LOG.info("AVS Agent initializing... ")
+
+    try:
+        interface_mappings = _parse_physical_interface_mappings(
+            cfg.CONF.AGENT.physical_interface_mappings)
+    except ValueError as e:
+        LOG.error("Parsing physical_interface_mappings failed: %s."
+                  " Agent terminated!", e)
+        sys.exit(1)
+
+    enable_dvr = cfg.CONF.AGENT.enable_distributed_routing
+
+    polling_interval = cfg.CONF.AVS.polling_interval
+    metering_interval = cfg.CONF.AVS.metering_interval
+    status_interval = cfg.CONF.AVS.status_interval
+
+    vswitch_api = api.VSwitchManagementAPI()
+
+    if tsconfig.sdn_enabled.lower() == 'yes':
+        agent_class = VSwitchSdnNeutronAgent
+    else:
+        agent_class = VSwitchNeutronAgent
+
+    agent = agent_class(interface_mappings,
+                        polling_interval,
+                        metering_interval,
+                        status_interval,
+                        vswitch_api,
+                        enable_dvr)
+
+    LOG.info("AVS Agent initialized successfully")
+    agent.daemon_loop()
+    sys.exit(0)
+
+if __name__ == "__main__":
+    main()
diff --git a/neutron/plugins/wrs/agent/avs/dvr.py b/neutron/plugins/wrs/agent/avs/dvr.py
new file mode 100644
index 0000000..2806352
--- /dev/null
+++ b/neutron/plugins/wrs/agent/avs/dvr.py
@@ -0,0 +1,300 @@
+#!/usr/bin/env python
+#
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2015-2017 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+#
+#
+# Based on the structure of the OpenVSwitch DVR agent in the
+# Neutron OpenVSwitch Plugin.
+
+import six
+
+from oslo_log import log as logging
+
+LOG = logging.getLogger(__name__)
+
+
+# A class to represent a DVR-hosted subnet including vif_ports resident on
+# that subnet
+class LocalDVRSubnetMapping(object):
+    def __init__(self, subnet):
+        # set of compute ports on on this dvr subnet
+        self.interfaces = set()
+        self.subnet = subnet
+        self.dvr_owned = False
+
+    def __str__(self):
+        return ("subnet = %s interfaces = %s is_dvr_owned = %s" %
+                (self.subnet, self.interfaces, self.is_dvr_owned()))
+
+    def get_subnet_info(self):
+        return self.subnet
+
+    def get_vlan_id(self):
+        return self.subnet.get('vlan_id', 0)
+
+    def set_dvr_owned(self, owned):
+        self.dvr_owned = owned
+
+    def is_dvr_owned(self):
+        return self.dvr_owned
+
+    def add_interface(self, interface_uuid):
+        """
+        Track which interfaces belong to which DVR subnet.
+        """
+        LOG.info("DVR: adding interface {} to subnet {} vlan {}".format(
+            interface_uuid, self.subnet['id'], self.get_vlan_id()))
+        self.interfaces.add(interface_uuid)
+
+    def remove_interface(self, interface_uuid):
+        """
+        Track which ports belong to which DVR subnet.
+        """
+        LOG.info("DVR: removing interface {} from "
+                 "subnet {} vlan {}".format(
+                     interface_uuid, self.subnet['id'],
+                     self.get_vlan_id()))
+        self.interfaces.discard(interface_uuid)
+
+
+class VswitchDVRNeutronAgent(object):
+    """
+    Implements Vswitch-based DVR(Distributed Virtual Router), for overlay
+    networks.
+    """
+    # history
+    #   1.0 Initial version
+
+    def __init__(self, context, plugin_rpc,
+                 agent,
+                 host=None,
+                 enable_distributed_routing=False):
+        self.context = context
+        self.plugin_rpc = plugin_rpc
+        self.agent = agent
+        self.host = host
+        self.enable_distributed_routing = enable_distributed_routing
+        self.local_dvr_map = {}
+        self.vswitch_mgr = None
+        self.registered_dvr_macs = {}
+        self.dvr_mac_address = None
+
+    def register_manager(self, manager):
+        self.vswitch_mgr = manager
+
+    def get_peer_dvr_mac_addresses(self):
+        """Find our local unique mac address as well as those of other hosts"""
+        # get the list of local/unique DVR MAC addresses
+        dvr_mac_list = self.plugin_rpc.get_dvr_mac_address_list(self.context)
+        LOG.debug("DVR: Server returned these local/unique "
+                  "MAC addresses {}".format(dvr_mac_list))
+        # parse the list and store a copy of the results
+        current_dvr_macs = {}
+        for mac in dvr_mac_list:
+            if mac['host'] == self.host:
+                continue
+            current_dvr_macs[mac['host']] = mac['mac_address']
+        # Update the cached copy and log any changes
+        self._update_peer_dvr_mac_addresses(current_dvr_macs)
+        # Send an update to AVS with the updated list
+        self._configure_avs_host_macs()
+
+    def get_dvr_mac_address(self):
+        """
+        Return the cached copy of our local unique MAC address or fetch it
+        from the server if we have not yet retrieved it.
+        """
+        if self.dvr_mac_address is None:
+            details = self.plugin_rpc.get_dvr_mac_address_by_host(
+                self.context, self.host)
+            LOG.info("DVR: local MAC address for host {} is {}".format(
+                self.host, details['mac_address']))
+            self.dvr_mac_address = details['mac_address']
+        return self.dvr_mac_address
+
+    def _get_interfaces_on_dvr_subnet(self, subnet_uuid):
+        ldm = self.local_dvr_map[subnet_uuid]
+        return list(ldm.interfaces)
+
+    def _get_local_interfaces_on_host_by_subnet(self, subnet):
+        local_ports = self.agent.get_ports_on_dvr_subnet(
+            subnet['id'], vlan_id=subnet['vlan_id'])
+        LOG.info("DVR: subnet {} local ports {}".format(
+            subnet['id'], local_ports))
+        return local_ports
+
+    def _get_peer_mac_addresses(self):
+        return [{'hostname': k, 'mac-address': v}
+                for k, v in six.iteritems(self.registered_dvr_macs)]
+
+    def _configure_avs_host_macs(self):
+        """
+        Update AVS with the list of known/unique MAC addresses.
+        """
+        dvr_peer_mac_addresses = self._get_peer_mac_addresses()
+        LOG.debug("DVR: configuring AVS with known/unique "
+                  "MAC addresses: {}".format(dvr_peer_mac_addresses))
+        self.vswitch_mgr.update_dvr_host_macs(dvr_peer_mac_addresses)
+
+    def _configure_avs_router_interface(self, interface_uuid,
+                                        subnet_uuid, gateway_ip):
+        """
+        Update the AVS AVR interface to configure it with DVR subnet
+        information.
+        """
+        dvr_interface_uuids = self._get_interfaces_on_dvr_subnet(subnet_uuid)
+        params = {'dvr-router-info':
+                  {'dvr-mac-address': self.get_dvr_mac_address(),
+                   'dvr-subnet-id': subnet_uuid,
+                   'dvr-ip-address': gateway_ip,
+                   'dvr-interfaces': dvr_interface_uuids}}
+        LOG.info("DVR: configuring router interface {} with {}".format(
+            interface_uuid, params))
+        self.vswitch_mgr.update_interface(interface_uuid, params)
+
+    def _configure_avs_interface(self, interface_uuid, subnet_uuid):
+        """
+        Update the AVS interface to configure it against the DVR enabled
+        subnet specified by subnet_uuid
+        """
+        params = {'dvr-interface-info':
+                  {'dvr-subnet-id': subnet_uuid}}
+        LOG.info("DVR: configuring interface {} with {}".format(
+            interface_uuid, params))
+        self.vswitch_mgr.update_interface(interface_uuid, params)
+
+    @staticmethod
+    def _find_subnet_details(subnet_uuid, port_details):
+        for s in port_details['subnets']:
+            subnet = s['subnet']
+            if subnet['id'] == subnet_uuid:
+                return subnet
+        return None
+
+    def bind_router_interface_to_dvr(self, interface_uuid, port_details):
+        """
+        Track which DVR subnet this router is attached to.
+        """
+        if not self.enable_distributed_routing:
+            return
+        # Router interfaces are only associated to a single subnet
+        fixed_ips = port_details['fixed_ips']
+        fixed_ip = fixed_ips[0]
+        subnet_uuid = fixed_ip['subnet_id']
+        gateway_ip = fixed_ip['ip_address']
+        LOG.info("DVR: binding router interface {} "
+                 "with IP {} on subnet {}".
+                 format(interface_uuid, gateway_ip, subnet_uuid))
+        if subnet_uuid in self.local_dvr_map:
+            ldm = self.local_dvr_map[subnet_uuid]
+        else:
+            # set up LocalDVRSubnetMapping available for this subnet
+            subnet_info = self._find_subnet_details(subnet_uuid, port_details)
+            if not subnet_info:
+                LOG.error("DVR: Unable to retrieve subnet information"
+                          " for subnet_id %s", subnet_uuid)
+                return
+            ldm = LocalDVRSubnetMapping(subnet_info)
+            self.local_dvr_map[subnet_uuid] = ldm
+        ldm.set_dvr_owned(True)
+        subnet_info = ldm.get_subnet_info()
+        # Fetch the current interfaces that hosted locally
+        local_interfaces = self._get_local_interfaces_on_host_by_subnet(
+            subnet_info)
+        for local_uuid in local_interfaces:
+            ldm.add_interface(local_uuid)
+        self._configure_avs_router_interface(
+            interface_uuid, subnet_uuid, gateway_ip)
+
+    def bind_interface_to_dvr(self, interface_uuid, port_details):
+        """
+        Track which DVR subnets this interface belongs to.
+        """
+        if not self.enable_distributed_routing:
+            return
+        fixed_subnet_list = self.agent.get_fixed_subnet_ids(port_details)
+        subnets = port_details.get('subnets', [])
+        for s in subnets:
+            subnet_uuid = s['subnet']['id']
+            if subnet_uuid not in fixed_subnet_list:
+                LOG.debug("DVR: interface {} has no IP in subnet {}; ignoring".
+                          format(interface_uuid, subnet_uuid))
+                continue
+            if subnet_uuid not in self.local_dvr_map:
+                LOG.debug("DVR: subnet {} not DVR enabled ignoring {}".format(
+                    subnet_uuid, interface_uuid))
+                continue
+            ldm = self.local_dvr_map[subnet_uuid]
+            if not ldm.is_dvr_owned():
+                LOG.debug("DVR: subnet {} not owned by DVR router {}".format(
+                    subnet_uuid, interface_uuid))
+                continue
+            ldm.add_interface(interface_uuid)
+            self._configure_avs_interface(interface_uuid, subnet_uuid)
+            # Stop at first DVR enabled subnet
+            return
+
+    def _update_peer_dvr_mac_addresses(self, current_dvr_macs):
+        if current_dvr_macs == self.registered_dvr_macs:
+            LOG.debug("DVR: MAC address list is already up to date")
+            return
+        existing_hosts = set(self.registered_dvr_macs.keys())
+        current_hosts = set(current_dvr_macs.keys())
+        # Calculate which hosts have been added/removed/updated
+        added = current_hosts - existing_hosts
+        removed = existing_hosts - current_hosts
+        updated = existing_hosts & current_hosts
+        # Update the stored MAC address list
+        for host in removed:
+            LOG.info("DVR: Removed unique MAC address {}={}".format(
+                host, self.registered_dvr_macs[host]))
+            self.registered_dvr_macs.pop(host, None)
+        for host in added:
+            LOG.info("DVR: Added unique MAC address {}={}".format(
+                host, current_dvr_macs[host]))
+            self.registered_dvr_macs[host] = current_dvr_macs[host]
+        for host in updated:
+            if current_dvr_macs[host] != self.registered_dvr_macs[host]:
+                LOG.info("DVR: Updated unique MAC address {}={}; "
+                         "previous was {}".format(
+                             host, current_dvr_macs[host],
+                             self.registered_dvr_macs[host]))
+                self.registered_dvr_macs[host] = current_dvr_macs[host]
+
+    def dvr_mac_address_update(self, dvr_macs):
+        """
+        Receive an updated list of unique host MAC addresses from the server
+        via RPC.  The server sends the full list whenever any one MAC changes.
+        """
+        if not self.enable_distributed_routing:
+            return
+        LOG.info("DVR: peer MAC address update: {}".format(dvr_macs))
+        current_dvr_macs = {}
+        for entry in dvr_macs:
+            if entry['host'] == self.host:
+                continue
+            current_dvr_macs[entry['host']] = entry['mac_address']
+        # Update the cached copy and log any changes
+        self._update_peer_dvr_mac_addresses(current_dvr_macs)
+        # Send an update to AVS with the updated list
+        self._configure_avs_host_macs()
diff --git a/neutron/plugins/wrs/drivers/mech_vswitch.py b/neutron/plugins/wrs/drivers/mech_vswitch.py
new file mode 100644
index 0000000..5e8eb17
--- /dev/null
+++ b/neutron/plugins/wrs/drivers/mech_vswitch.py
@@ -0,0 +1,145 @@
+# Copyright (c) 2014 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+from oslo_log import log as logging
+
+from neutron_lib.api.definitions import portbindings
+
+from neutron._i18n import _
+from neutron.agent import securitygroups_rpc
+from neutron.common import constants
+from neutron.extensions import wrs_binding
+from neutron.plugins.ml2 import driver_api as api
+from neutron.plugins.ml2.drivers import mech_agent
+from oslo_config import cfg
+
+LOG = logging.getLogger(__name__)
+
+VHOST_OPTS = [
+    cfg.BoolOpt('vhost_user_enabled', default=True,
+               help=_('Enable vhost-user backed virtio devices')),
+    cfg.StrOpt('vhost_user_socket_path',
+               default='/var/run/vswitch',
+               help=_("Where to store vhost-user unix socket")),
+    cfg.StrOpt('vhost_user_socket_prefix',
+               default='usvhost',
+               help=_("vhost-user unix socket name prefix")),
+]
+
+CONF = cfg.CONF
+CONF.register_opts(VHOST_OPTS, "vhost")
+
+VHOST_USER_MODE = portbindings.VHOST_USER_MODE
+VHOST_USER_MODE_CLIENT = portbindings.VHOST_USER_MODE_CLIENT
+VHOST_USER_SOCKET = portbindings.VHOST_USER_SOCKET
+VHOST_USER_ENABLED = wrs_binding.VHOST_USER_ENABLED
+
+
+class VSwitchMechanismDriver(mech_agent.SimpleAgentMechanismDriverBase):
+    """Attach to networks using Wind River vSwitch L2 agent.
+
+    The VSwitchMechanismDriver integrates the ml2 plugin with the
+    vswitch L2 agent. Port binding with this driver requires the
+    vswitch agent to be running on the port's host, and that agent
+    to have connectivity to at least one segment of the port's
+    network.
+    """
+
+    def __init__(self):
+        sg_enabled = securitygroups_rpc.is_firewall_enabled()
+        vif_details = {portbindings.CAP_PORT_FILTER: sg_enabled}
+        super(VSwitchMechanismDriver, self).__init__(
+            constants.AGENT_TYPE_WRS_VSWITCH,
+            wrs_binding.VIF_TYPE_AVS,
+            vif_details)
+
+    def try_to_bind_segment_for_agent(self, context, segment, agent):
+        if self.check_segment_for_agent(segment, agent):
+            vif_details = self.vif_details.copy()
+            if self.check_vhostuser(context):
+                port = context.current
+                vif_model = port.get(wrs_binding.VIF_MODEL)
+                if vif_model == wrs_binding.VIF_MODEL_VIRTIO:
+                    sock_path = ("%s/%s-%s" %
+                                 (CONF.vhost.vhost_user_socket_path,
+                                  CONF.vhost.vhost_user_socket_prefix,
+                                  port['id']))
+                    vif_details[VHOST_USER_MODE] = VHOST_USER_MODE_CLIENT
+                    vif_details[VHOST_USER_SOCKET] = sock_path
+            else:
+                vif_details[VHOST_USER_ENABLED] = False
+
+            context.set_binding(segment[api.ID],
+                                self.vif_type,
+                                vif_details)
+            return True
+        else:
+            return False
+
+    def get_allowed_network_types(self, agent=None):
+        """Return the agent's or driver's allowed network types."""
+        # The 'local' type is include for SRIOV support
+        network_types = ['flat', 'vlan', 'vxlan', 'local']
+        return network_types
+
+    def get_mappings(self, agent):
+        """Return the agent's bridge or interface mappings."""
+        mappings = agent['configurations'].get('mappings', {})
+        return mappings
+
+    def check_segment_for_agent(self, segment, agent):
+        result = (super(VSwitchMechanismDriver, self).
+                  check_segment_for_agent(segment, agent))
+        if not result:
+            return result
+        mappings = self.get_mappings(agent)
+        network_type = segment[api.NETWORK_TYPE]
+        if network_type in ['vxlan']:
+            # The parent class does not check whether the physical network is
+            # included in the reported mappings when the network_type because
+            # they assume VXLAN provider networks to be universally available
+            physnet = segment[api.PHYSICAL_NETWORK]
+            if not self.physnet_in_mappings(physnet, mappings):
+                LOG.debug(
+                    'Network %(network_id)s is connected to physical '
+                    'network %(physnet)s, but agent %(agent)s reported '
+                    'physical networks %(mappings)s. '
+                    'The physical network must be configured on the '
+                    'agent if binding is to succeed.',
+                    {'network_id': segment['id'],
+                     'physnet': physnet,
+                     'agent': agent['host'],
+                     'mappings': mappings})
+                return False
+        # Otherwise trust the decision made by the parent class
+        return True
+
+    def check_vlan_transparency(self, context):
+        """Report that VLAN transparency is supported."""
+        return True
+
+    def check_vhostuser(self, context):
+        """Return the vhostuser support status."""
+        if context.vif_details:
+            return (CONF.vhost.vhost_user_enabled and
+                    context.vif_details.get(VHOST_USER_ENABLED, True))
+        return CONF.vhost.vhost_user_enabled
diff --git a/neutron/services/segments/db.py b/neutron/services/segments/db.py
index b71fda7..99f8bba 100644
--- a/neutron/services/segments/db.py
+++ b/neutron/services/segments/db.py
@@ -211,6 +211,8 @@ def _get_phys_nets(agent):
     mappings = configurations_dict.get('bridge_mappings', {})
     mappings.update(configurations_dict.get('interface_mappings', {}))
     mappings.update(configurations_dict.get('device_mappings', {}))
+    # TODO(alegacy): need to align our attribute name to one of the above
+    mappings.update(configurations_dict.get('mappings', {}))
     return list(mappings.keys())
 
 
diff --git a/neutron/tests/functional/vswitch/__init__.py b/neutron/tests/functional/vswitch/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/neutron/tests/functional/vswitch/test_vswitch_agent.py b/neutron/tests/functional/vswitch/test_vswitch_agent.py
new file mode 100644
index 0000000..72f151e
--- /dev/null
+++ b/neutron/tests/functional/vswitch/test_vswitch_agent.py
@@ -0,0 +1,243 @@
+# Copyright (c) 2013 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+#
+# Copyright (c) 2013-2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+import uuid
+
+import six
+
+import fixtures
+import testtools
+
+from neutron.agent.vswitch import api
+from neutron.agent.vswitch import constants
+from neutron.agent.vswitch import exceptions
+from neutron.agent.vswitch import manager
+from neutron.common import constants as q_constants
+
+
+class TestVSwitchManager(testtools.TestCase):
+
+    def setUp(self):
+        super(TestVSwitchManager, self).setUp()
+        self.useFixture(fixtures.FakeLogger())
+        self.api = api.VSwitchManagementAPI()
+        self.port = {
+            'type': constants.VSWITCH_AVP_GUEST_PORT,
+            'uuid': str(uuid.uuid4()),
+            'mac-address': "00:11:22:33:44:55",
+            'neutron': True}
+        self.mappings = self._resolve_interface_mappings({
+            'physnet0': 'eth0',
+            'physnet1': 'eth1'})
+        self.manager = manager.VSwitchManager(self.api, self.mappings)
+        self.network = {
+            'port_id': str(uuid.uuid4()),
+            'network_id': str(uuid.uuid4()),
+            'mtu': 1500,
+            'segmentation_id': 1000,
+            'network_type': 'vlan',
+            'physical_network': 'physnet0',
+            'vlan_transparent': False}
+
+    def tearDown(self):
+        super(TestVSwitchManager, self).tearDown()
+        for port in self.api.get_port_list():
+            if port['type'] != "physical":
+                self.api.lock_port(port)
+                if 'network-uuid' in port:
+                    self.api.detach_port(port)
+                self.api.delete_port(port)
+        for interface in self.api.get_interface_list():
+            try:
+                self.api.detach_interface(interface)
+            except exceptions.VSwitchError:
+                # Ignore for now... should not fail on unattached interface
+                pass
+            if interface['type'] in ['vlan', 'vxlan']:
+                self.api.delete_interface(interface)
+        for network in self.api.get_network_list():
+            self.api.delete_network(network)
+
+    def _resolve_interface_mappings(self, mappings):
+        """
+        Translate the interface mappings from names to uuid values.
+        """
+        result = {}
+        interfaces = {i['name']: i for i in self.api.get_interface_list()}
+        for physical_network, ifname in six.iteritems(mappings):
+            result = {physical_network: interfaces[ifname]['uuid']}
+        return result
+
+    def add_network(self, network):
+        uuid = self.network['network_id']
+        network['name'] = self.manager.get_network_name(uuid)
+        self.manager.setup_network(uuid, network)
+
+    def delete_network(self, network_id):
+        self.manager.delete_network(network_id)
+
+    def test_lock_port(self):
+        ports = self.api.get_port_list()
+        self.manager.lock_port(getattr(ports[0], 'uuid'))
+
+    def test_unlock_port(self):
+        ports = self.api.get_port_list()
+        self.manager.unlock_port(getattr(ports[0], 'uuid'))
+
+    def test_lock_port_non_existent(self):
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.manager.lock_port,
+            str(uuid.uuid4()))
+
+    def test_unlock_port_non_existent(self):
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.manager.unlock_port,
+            str(uuid.uuid4()))
+
+    def test_find_interface(self):
+        interface = self.manager.find_interface('eth0')
+        self.assertIsNotNone(interface)
+        self.assertEqual(getattr(interface, 'name'), 'eth0')
+
+    def test_attach_port(self):
+        self.test_add_network_on_vlan()
+        self.api.add_port(self.port)
+        self.manager.attach_port(self.port['uuid'], self.network['network_id'])
+
+    def test_attach_port_not_existent_port(self):
+        self.test_add_network_on_vlan()
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.manager.attach_port,
+            self.port['uuid'], self.network['network_id'])
+
+    def test_attach_port_not_existent_network(self):
+        self.api.add_port(self.port)
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.manager.attach_port,
+            self.port['uuid'], self.network['network_id'])
+
+    def test_add_vlan_transparent_network(self):
+        self.network['segmentation_id'] = None
+        self.network['network_type'] = 'flat'
+        self.network['vlan_transparent'] = True
+        self.add_network(self.network)
+        count = 0
+        for interface in self.api.get_interface_list():
+            if interface['type'] == constants.VSWITCH_VLAN_INTERFACE:
+                count = count + 1
+        self.assertEqual(count, 0)
+
+    def test_add_network_on_ethernet(self):
+        self.network['segmentation_id'] = None
+        self.network['network_type'] = 'flat'
+        self.add_network(self.network)
+        count = 0
+        for interface in self.api.get_interface_list():
+            if interface['type'] == constants.VSWITCH_VLAN_INTERFACE:
+                count = count + 1
+        self.assertEqual(count, 0)
+
+    def test_add_network_on_vlan(self):
+        self.add_network(self.network)
+        count = 0
+        for interface in self.api.get_interface_list():
+            if interface['type'] == constants.VSWITCH_VLAN_INTERFACE:
+                count = count + 1
+        self.assertNotEqual(count, 0)
+
+    def test_add_network_on_vxlan(self):
+        self.network['network_type'] = 'vxlan'
+        self.network['vxlan'] = {'group': '239.0.0.9',
+                                 'port': 4789,
+                                 'ttl': 1}
+        self.network['mtu'] = (int(self.network['mtu']) -
+                               q_constants.VXLAN_MTU_OVERHEAD)
+        self.add_network(self.network)
+        count = 0
+        for interface in self.api.get_interface_list():
+            if interface['type'] == constants.VSWITCH_VXLAN_INTERFACE:
+                count = count + 1
+        self.assertNotEqual(count, 0)
+
+    def test_add_network_on_vlan_zero(self):
+        self.network['segmentation_id'] = 0
+        self.assertRaises(manager.VSwitchManagerError,
+                          self.add_network,
+                          self.network)
+
+# Disable until vswitch ignores duplicate networks
+#
+#    def test_add_duplicate_network(self):
+#        self.assertTrue(self.add_network(self.network))
+#        self.assertTrue(self.add_network(self.network))
+
+    def test_add_network_invalid_physical_network(self):
+        self.network['physical_network'] = 'xxx'
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.add_network,
+            self.network)
+
+    def test_add_network_invalid_ethernet_interface(self):
+        self.network['segmentation_id'] = None
+        self.network['physical_network'] = 'physnet9'
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.add_network,
+            self.network)
+
+    def test_add_network_invalid_vlan_interface(self):
+        self.network['physical_network'] = 'physnet9'
+        self.assertRaises(
+            manager.VSwitchManagerError,
+            self.add_network,
+            self.network)
+
+    def test_delete_network(self):
+        self.add_network(self.network)
+        self.delete_network(self.network['network_id'])
+
+    def test_delete_network_non_existent(self):
+        self.assertRaises(manager.VSwitchManagerError,
+                          self.delete_network,
+                          str(uuid.uuid4()))
+
+    def test_get_port_count(self):
+        count = self.manager.get_virtual_port_count()
+        self.assertEqual(count, 0)
+        self.api.add_port(self.port)
+        count = self.manager.get_virtual_port_count()
+        self.assertEqual(count, 1)
+        self.api.delete_port(self.port)
+
+    def test_get_port_status(self):
+        ports = self.api.get_port_list()
+        self.manager.get_port_status(getattr(ports[0], 'uuid'))
+
+    def test_get_port_status_non_existent(self):
+        self.assertRaises(manager.VSwitchManagerError,
+                          self.manager.get_port_status,
+                          str(uuid.uuid4()))
diff --git a/neutron/tests/functional/vswitch/test_vswitch_api.py b/neutron/tests/functional/vswitch/test_vswitch_api.py
new file mode 100644
index 0000000..64f086c
--- /dev/null
+++ b/neutron/tests/functional/vswitch/test_vswitch_api.py
@@ -0,0 +1,448 @@
+# Copyright (c) 2013 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+#
+# Copyright (c) 2013-2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+import uuid
+
+import fixtures
+import testtools
+
+from neutron.agent.vswitch import api
+from neutron.agent.vswitch import constants
+from neutron.agent.vswitch import exceptions
+
+
+class TestVSwitchManagementAPI(testtools.TestCase):
+
+    def ignoreError(self, callable):
+        try:
+            callable()
+        except Exception:
+            pass
+
+    def setUp(self):
+        super(TestVSwitchManagementAPI, self).setUp()
+        self.useFixture(fixtures.FakeLogger())
+        self.api = api.VSwitchManagementAPI()
+        ports = self.api.get_port_list()
+        self.lower_uuid = ports[0]['interface-uuid']
+        self.port = {
+            'type': constants.VSWITCH_AVP_GUEST_PORT,
+            'uuid': str(uuid.uuid4()),
+            'mac-address': "00:11:22:33:44:55"}
+        self.network = {
+            'type': constants.VSWITCH_LAYER2_NETWORK,
+            'uuid': str(uuid.uuid4()),
+            'name': 'test-net1'}
+        self.interface = {
+            'type': constants.VSWITCH_VLAN_INTERFACE,
+            'uuid': str(uuid.uuid4()),
+            'vlan-id': 99,
+            'mtu': 1500}
+        self.neighbour4 = {"mac-address": "02:11:22:33:44:55",
+                           "address": "1.2.3.4",
+                           "interface-uuid": self.lower_uuid}
+        self.neighbour6 = {"mac-address": "02:11:22:33:44:56",
+                          "address": "fd6c:cbf:d1d1::1",
+                           "interface-uuid": self.lower_uuid}
+        self.neighbours = [self.neighbour4, self.neighbour6]
+        self.address4 = {"address": "192.168.1.2",
+                         "prefix-length": 24,
+                         "interface-uuid": self.lower_uuid}
+        self.address6 = {"address": "cc:dd::2",
+                         "prefix-length": 120,
+                         "interface-uuid": self.lower_uuid}
+        self.addresses = [self.address4, self.address6]
+        self.route4 = {"prefix": "192.168.0.0",
+                       "prefix-length": 24,
+                       "nexthops": [{"interface-uuid": self.lower_uuid,
+                                     "gateway": "192.168.1.1",
+                                     "weight": 10,
+                                     "lifetime": 86400}]}
+        self.route6 = {"prefix": "aa:bb::",
+                       "prefix-length": 120,
+                       "nexthops": [{"interface-uuid": self.lower_uuid,
+                                     "gateway": "cc:dd::1",
+                                     "weight": 10,
+                                     "lifetime": 86400}]}
+        self.routes = [self.route4, self.route6]
+        self.router = {"name": "test-router0",
+                       "uuid": str(uuid.uuid4())}
+        self.routers = [self.router]
+        self.router_interface = {"type": constants.VSWITCH_ROUTER_INTERFACE,
+                                 "name": "router0-if0",
+                                 "uuid": str(uuid.uuid4()),
+                                 "mac-address": "02:23:45:67:89:9a",
+                                 "mtu": 1500,
+                                 "router-uuid": self.router["uuid"]}
+        self.router_interfaces = [self.router_interface]
+
+    def tearDown(self):
+        super(TestVSwitchManagementAPI, self).tearDown()
+        for port in self.api.get_port_list():
+            if port['type'] != "physical":
+                self.api.lock_port(port)
+                if 'network-uuid' in port:
+                    self.api.detach_port(port)
+                self.api.delete_port(port)
+        for interface in self.api.get_interface_list():
+            if 'network-uuid' in interface:
+                self.api.detach_interface(interface)
+            if interface['type'] == constants.VSWITCH_VLAN_INTERFACE:
+                self.api.delete_interface(interface)
+        for network in self.api.get_network_list():
+            self.api.delete_network(network)
+        for neighbour in self.neighbours:
+            self.ignoreError(lambda n=neighbour: self.api.delete_neighbour(n))
+        for route in self.routes:
+            self.ignoreError(lambda r=route: self.api.delete_route(r))
+        for address in self.addresses:
+            self.ignoreError(lambda a=address: self.api.delete_address(a))
+        for router_interface in self.router_interfaces:
+            self.ignoreError(
+                lambda i=router_interface: self.api.delete_interface(i))
+        for router in self.routers:
+            self.ignoreError(lambda: self.api.delete_router(router))
+
+    def test_get_port_list(self):
+        ports = self.api.get_port_list()
+        self.assertIsNotNone(ports)
+        self.assertNotEqual(len(ports), 0)
+
+    def test_get_port(self):
+        ports = self.api.get_port_list()
+        self.assertIsNotNone(ports)
+        self.assertGreater(len(ports), 0)
+        port = self.api.get_port(getattr(ports[0], 'uuid'))
+        self.assertIsNotNone(port)
+        self.assertEqual(port['uuid'], getattr(ports[0], 'uuid'))
+
+    def test_get_port_not_existent(self):
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.get_port,
+                          (str(uuid.uuid4())))
+
+    def test_get_port_status(self):
+        ports = self.api.get_port_list()
+        self.assertIsNotNone(ports)
+        self.assertGreater(len(ports), 0)
+        port = self.api.get_port(getattr(ports[0], 'uuid'))
+        self.assertIsNotNone(port)
+        self.assertIn('admin-state', port)
+        self.assertIn('link-state', port)
+        status = self.api.get_port_status(port)
+        self.assertIsNotNone(status)
+        if status:
+            self.assertEqual(port['admin-state'], 'up')
+            self.assertEqual(port['link-state'], 'up')
+        else:
+            self.assertEqual(port['link-state'], 'down')
+
+    def test_get_port_status_not_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.get_port_status,
+                          self.port)
+
+    def test_add_port(self):
+        port = self.api.add_port(self.port)
+        for key in self.port.keys():
+            self.assertEqual(self.port[key], port[key])
+
+    def test_add_port_duplicate(self):
+        port1 = self.api.add_port(self.port)
+        port2 = self.api.add_port(self.port)
+        self.assertIsNotNone(port1)
+        self.assertIsNone(port2)
+
+    def test_add_port_missing_uuid(self):
+        del self.port['uuid']
+        self.assertRaises(exceptions.VSwitchError,
+                          self.api.add_port, self.port)
+
+    def test_add_port_missing_mac(self):
+        del self.port['mac-address']
+        self.assertRaises(exceptions.VSwitchError,
+                          self.api.add_port, self.port)
+
+    def test_add_port_missing_type(self):
+        del self.port['type']
+        self.assertRaises(exceptions.VSwitchError,
+                          self.api.add_port, self.port)
+
+    def test_add_port_invalid_uuid(self):
+        self.port['uuid'] = '1234'
+        self.assertRaises(exceptions.VSwitchPortError,
+                          self.api.add_port, self.port)
+
+    def test_add_port_invalid_mac(self):
+        self.port['mac-address'] = '1234'
+        self.assertRaises(exceptions.VSwitchError,
+                          self.api.add_port, self.port)
+
+    def test_add_port_invalid_type(self):
+        self.port['type'] = '1234'
+        self.assertRaises(exceptions.VSwitchError,
+                          self.api.add_port, self.port)
+
+    def test_lock_port(self):
+        for port in self.api.get_port_list():
+            self.api.lock_port(port)
+
+    def test_lock_port_already_locked(self):
+        for port in self.api.get_port_list():
+            self.api.lock_port(port)
+            self.api.lock_port(port)
+
+    def test_unlock_port(self):
+        for port in self.api.get_port_list():
+            self.api.unlock_port(port)
+
+    def test_unlock_port_already_unlocked(self):
+        for port in self.api.get_port_list():
+            self.api.unlock_port(port)
+            self.api.unlock_port(port)
+
+    def test_lock_port_not_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.unlock_port, self.port)
+
+    def test_unlock_port_not_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.unlock_port, self.port)
+
+    def test_delete_port(self):
+        port = self.api.add_port(self.port)
+        self.api.delete_port(port)
+
+    def test_delete_port_non_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.api.delete_port(self.port)
+
+    def test_destroy_port(self):
+        port = self.api.add_port(self.port)
+        self.api.destroy_port(port)
+
+    def test_destroy_port_non_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.api.destroy_port(self.port)
+
+    def test_attach_port(self):
+        port = self.api.add_port(self.port)
+        self.assertIsNotNone(port)
+        self.api.add_network(self.network)
+        self.port['network-uuid'] = self.network['uuid']
+        self.api.attach_port(self.port)
+        port = self.api.get_port(self.port['uuid'])
+        self.assertIsNotNone(port)
+        self.assertIn('network-uuid', port)
+        self.assertEqual(port['network-uuid'], self.network['uuid'])
+
+    def test_attach_port_not_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.port['network-uuid'] = self.network['uuid']
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.attach_port, self.port)
+
+    def test_attach_port_network_not_found(self):
+        port = self.api.add_port(self.port)
+        self.assertIsNotNone(port)
+        self.port['network-uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.attach_port, self.port)
+
+    def test_attach_port_network_invalid_uuid(self):
+        port = self.api.add_port(self.port)
+        self.assertIsNotNone(port)
+        self.port['network-uuid'] = '1234'
+        self.assertRaises(exceptions.VSwitchPortError,
+                          self.api.attach_port, self.port)
+
+    def test_detach_port(self):
+        port = self.api.add_port(self.port)
+        self.assertIsNotNone(port)
+        self.api.add_network(self.network)
+        self.port['network-uuid'] = self.network['uuid']
+        self.api.attach_port(self.port)
+        port = self.api.get_port(self.port['uuid'])
+        self.assertIsNotNone(port)
+        self.assertIn('network-uuid', port)
+        self.assertEqual(port['network-uuid'], self.network['uuid'])
+        self.api.detach_port(port)
+
+    def test_detach_port_not_existent(self):
+        self.port['uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchPortNotFoundError,
+                          self.api.detach_port, self.port)
+
+    def test_detach_port_not_attached(self):
+        port = self.api.add_port(self.port)
+        self.assertIsNotNone(port)
+        self.api.detach_port(port)
+
+    def test_get_interface_list(self):
+        interfaces = self.api.get_interface_list()
+        count = len(interfaces)
+        self.assertIsNotNone(interfaces)
+        self.assertNotEqual(count, 0)
+        self.test_add_interface()
+        interfaces = self.api.get_interface_list()
+        self.assertIsNotNone(interfaces)
+        self.assertEqual(len(interfaces), count + 1)
+
+    def test_get_interface(self):
+        interfaces = self.api.get_interface_list()
+        self.assertIsNotNone(interfaces)
+        self.assertNotEqual(len(interfaces), 0)
+        interface = self.api.get_interface(getattr(interfaces[0], 'uuid'))
+        self.assertIsNotNone(interface)
+        self.assertEqual(interface['uuid'], getattr(interfaces[0], 'uuid'))
+
+    def test_get_interface_not_existent(self):
+        self.assertRaises(exceptions.VSwitchInterfaceNotFoundError,
+                          self.api.get_interface,
+                          (str(uuid.uuid4())))
+
+    def test_add_interface(self):
+        interfaces = self.api.get_interface_list()
+        self.assertGreater(len(interfaces), 0)
+        self.interface['lower-uuid'] = getattr(interfaces[0], 'uuid')
+        self.interface['mtu'] = getattr(interfaces[0], 'mtu')
+        interface = self.api.add_interface(self.interface)
+        self.assertIsNotNone(interface)
+        self.assertEqual(interface['uuid'], self.interface['uuid'])
+
+    def test_add_interface_duplicate(self):
+        interfaces = self.api.get_interface_list()
+        self.assertGreater(len(interfaces), 0)
+        self.interface['lower-uuid'] = getattr(interfaces[0], 'uuid')
+        interface = self.api.add_interface(self.interface)
+        self.assertIsNotNone(interface)
+        self.assertEqual(interface['uuid'], self.interface['uuid'])
+
+    def test_add_interface_invalid_lower(self):
+        self.interface['lower-uuid'] = str(uuid.uuid4())
+        self.assertRaises(exceptions.VSwitchInterfaceNotFoundError,
+                          self.api.add_interface,
+                          self.interface)
+
+    def test_delete_interface(self):
+        interfaces = self.api.get_interface_list()
+        self.assertGreater(len(interfaces), 0)
+        self.interface['lower-uuid'] = getattr(interfaces[0], 'uuid')
+        interface = self.api.add_interface(self.interface)
+        self.assertIsNotNone(interface)
+        self.assertEqual(interface['uuid'], self.interface['uuid'])
+        self.api.delete_interface(interface)
+
+    def test_delete_interface_not_existent(self):
+        self.interface['uuid'] = str(uuid.uuid4())
+        self.api.delete_interface(self.interface)
+
+    def test_get_network_list(self):
+        networks = self.api.get_network_list()
+        self.assertIsNotNone(networks)
+        self.assertEqual(len(networks), 0)
+
+    def test_add_network(self):
+        count = len(self.api.get_network_list())
+        self.assertEqual(count, 0)
+        network = self.api.add_network(self.network)
+        self.assertIsNotNone(network)
+        self.assertIn('uuid', network)
+        self.assertEqual(network['uuid'], self.network['uuid'])
+        count = len(self.api.get_network_list())
+        self.assertEqual(count, 1)
+
+    def test_add_network_duplicate(self):
+        network = self.api.add_network(self.network)
+        self.assertIsNotNone(network)
+        self.assertIn('uuid', network)
+        self.assertEqual(network['uuid'], self.network['uuid'])
+        count = len(self.api.get_network_list())
+        self.assertEqual(count, 1)
+        network = self.api.add_network(self.network)
+        count = len(self.api.get_network_list())
+        self.assertEqual(count, 1)
+
+    def test_delete_network(self):
+        network = self.api.add_network(self.network)
+        self.assertIsNotNone(network)
+        self.api.delete_network(network)
+        count = len(self.api.get_network_list())
+        self.assertEqual(count, 0)
+
+    def test_delete_network_not_existent(self):
+        self.api.delete_network(self.network)
+
+    def test_add_ipv4_neighbour(self):
+        neighbour = self.api.add_neighbour(self.neighbour4)
+        self.assertIsNotNone(neighbour)
+        self.api.delete_neighbour(neighbour)
+
+    def test_add_ipv4_address(self):
+        address = self.api.add_address(self.address4)
+        self.assertIsNotNone(address)
+        self.api.delete_address(address)
+
+    def test_add_ipv4_route(self):
+        self.api.add_address(self.address4)
+        route = self.api.add_route(self.route4)
+        self.assertIsNotNone(route)
+        self.api.delete_route(route)
+
+    def test_add_ipv6_neighbour(self):
+        neighbour = self.api.add_neighbour(self.neighbour6)
+        self.assertIsNotNone(neighbour)
+        self.api.delete_neighbour(neighbour)
+
+    def test_add_ipv6_address(self):
+        address = self.api.add_address(self.address6)
+        self.assertIsNotNone(address)
+        self.api.delete_address(address)
+
+    def test_add_ipv6_route(self):
+        self.api.add_address(self.address6)
+        route = self.api.add_route(self.route6)
+        self.assertIsNotNone(route)
+        self.api.delete_route(route)
+
+    def test_get_router(self):
+        self.api.add_router(self.router)
+        router = self.api.get_router(self.router['uuid'])
+        self.assertIsNotNone(router)
+
+    def test_add_router(self):
+        router = self.api.add_router(self.router)
+        self.assertIsNotNone(router)
+        self.api.delete_router(router)
+
+    def test_add_router_interface(self):
+        router = self.api.add_router(self.router)
+        self.assertIsNotNone(router)
+        interface = self.api.add_interface(self.router_interface)
+        self.assertIsNotNone(interface)
+        self.assertEqual(interface['router-uuid'], self.router['uuid'])
+        self.api.delete_interface(interface)
+        self.api.delete_router(router)
diff --git a/neutron/tests/functional/vswitch/test_vswitch_interface.py b/neutron/tests/functional/vswitch/test_vswitch_interface.py
new file mode 100644
index 0000000..ad0dc91
--- /dev/null
+++ b/neutron/tests/functional/vswitch/test_vswitch_interface.py
@@ -0,0 +1,113 @@
+# Copyright 2012 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Copyright (c) 2013-2017 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+import uuid
+
+import fixtures
+import testtools
+
+from neutron.agent.common import config
+from neutron.agent.linux import interface as linux_interface
+from neutron.agent.linux import ip_lib
+from neutron.agent.vswitch import api
+from neutron.agent.vswitch import interface
+from neutron.common import constants as n_const
+
+
+class FakeNetwork(object):
+    id = '12345678-1234-5678-90ab-ba0987654321'
+
+
+class FakePort(object):
+    id = 'abcdef01-1234-5678-90ab-ba0987654321'
+    device_id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'
+    network = FakeNetwork()
+    network_id = network.id
+
+
+class TestVSwitchInterfaceDriver(testtools.TestCase):
+
+    def setUp(self):
+        super(TestVSwitchInterfaceDriver, self).setUp()
+        self.useFixture(fixtures.FakeLogger())
+        self.conf = config.setup_conf()
+        self.conf.register_opts(linux_interface.OPTS)
+        config.register_root_helper(self.conf)
+        self.driver = interface.VSwitchInterfaceDriver(self.conf)
+        self.api = api.VSwitchManagementAPI()
+        self.mac_address = 'aa:bb:cc:dd:ee:ff'
+        self.network_id = str(uuid.uuid4())
+        self.port_id = str(uuid.uuid4())
+        self.port = FakePort()
+        self.port.id = self.port_id
+        self.namespace_id = str(uuid.uuid4())
+        self.plugged = False
+        self.ip = ip_lib.IPWrapper(namespace=self.namespace_id)
+
+    def tearDown(self):
+        super(TestVSwitchInterfaceDriver, self).tearDown()
+        if self.plugged:
+            self.driver.unplug(self.driver.get_device_name(self.port))
+            self.plugged = False
+
+    def test_get_device_name(self):
+        device_name = self.driver.get_device_name(FakePort())
+        self.assertEqual('avpabcdef01-12', device_name)
+
+    def test_find_port_by_device_name(self):
+        port = FakePort()
+        ports = self.api.get_port_list()
+        port.id = getattr(ports[0], 'uuid')
+        device_name = self.driver.get_device_name(port)
+        x = self.driver._find_port_by_device_name(device_name)
+        self.assertEqual(x, ports[0])
+
+    def test_find_port_missing_port(self):
+        port = FakePort()
+        device_name = self.driver.get_device_name(port)
+        x = self.driver._find_port_by_device_name(device_name)
+        self.assertIsNone(x)
+
+    def test_plug_with_ns(self):
+        self.test_plug(namespace=self.namespace_id)
+
+    def test_plug(self, namespace=None, mtu=n_const.DEFAULT_MTU):
+        ports = self.api.get_port_list()
+        count = len(ports)
+        self.driver.plug(self.network_id,
+                         self.port_id,
+                         self.driver.get_device_name(self.port),
+                         self.mac_address,
+                         namespace=self.namespace_id,
+                         mtu=mtu)
+        self.plugged = True
+        ports = self.api.get_port_list()
+        self.assertGreater(len(ports), count)
+
+    def test_unplug(self):
+        self.test_plug()
+        ports = self.api.get_port_list()
+        count = len(ports)
+        self.driver.unplug(self.driver.get_device_name(self.port))
+        self.plugged = False
+        ports = self.api.get_port_list()
+        self.assertLess(len(ports), count)
diff --git a/neutron/tests/unit/plugins/wrs/drivers/test_mech_vswitch.py b/neutron/tests/unit/plugins/wrs/drivers/test_mech_vswitch.py
new file mode 100644
index 0000000..90d2ffb
--- /dev/null
+++ b/neutron/tests/unit/plugins/wrs/drivers/test_mech_vswitch.py
@@ -0,0 +1,81 @@
+# Copyright (c) 2013 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+# Copyright (c) 2013-2015 Wind River Systems, Inc.
+#
+# The right to copy, distribute, modify, or otherwise make use
+# of this software may be licensed only pursuant to the terms
+# of an applicable Wind River license agreement.
+#
+
+from neutron.common import constants
+from neutron.extensions import wrs_binding
+from neutron.plugins.wrs.drivers import mech_vswitch
+from neutron.tests.unit.plugins.ml2 import _test_mech_agent as base
+
+
+class VSwitchMechanismBaseTestCase(base.AgentMechanismBaseTestCase):
+    VIF_TYPE = wrs_binding.VIF_TYPE_AVS
+    CAP_PORT_FILTER = True
+
+    AGENT_TYPE = constants.AGENT_TYPE_WRS_VSWITCH
+
+    GOOD_MAPPINGS = {'fake_physical_network': 'fake_bridge'}
+    GOOD_CONFIGS = {'mappings': GOOD_MAPPINGS}
+
+    BAD_MAPPINGS = {'wrong_physical_network': 'wrong_bridge'}
+    BAD_CONFIGS = {'mappings': BAD_MAPPINGS}
+
+    AGENTS = [{'alive': True,
+               'configurations': GOOD_CONFIGS,
+               'host': 'host'}]
+    AGENTS_DEAD = [{'alive': False,
+                    'configurations': GOOD_CONFIGS,
+                    'host': 'dead_host'}]
+    AGENTS_BAD = [{'alive': False,
+                   'configurations': GOOD_CONFIGS,
+                   'host': 'bad_host_1'},
+                  {'alive': True,
+                   'configurations': BAD_CONFIGS,
+                   'host': 'bad_host_2'}]
+
+    def setUp(self):
+        super(VSwitchMechanismBaseTestCase, self).setUp()
+        self.driver = mech_vswitch.VSwitchMechanismDriver()
+        self.driver.initialize()
+
+
+class VSwitchMechanismGenericTestCase(VSwitchMechanismBaseTestCase,
+                                      base.AgentMechanismGenericTestCase):
+    pass
+
+
+class VSwitchMechanismLocalTestCase(VSwitchMechanismBaseTestCase,
+                                    base.AgentMechanismLocalTestCase):
+    pass
+
+
+class VSwitchMechanismFlatTestCase(VSwitchMechanismBaseTestCase,
+                                   base.AgentMechanismFlatTestCase):
+    pass
+
+
+class VSwitchMechanismVlanTestCase(VSwitchMechanismBaseTestCase,
+                                   base.AgentMechanismVlanTestCase):
+    pass
+
+
+class VSwitchMechanismVxlanTestCase(VSwitchMechanismBaseTestCase,
+                                    base.AgentMechanismVxlanTestCase):
+    pass
diff --git a/setup.cfg b/setup.cfg
index 1e3f41f..b438ad7 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -66,6 +66,8 @@ console_scripts =
     neutron-metering-agent = neutron.cmd.eventlet.services.metering_agent:main
     neutron-sriov-nic-agent = neutron.cmd.eventlet.plugins.sriov_nic_neutron_agent:main
     neutron-sanity-check = neutron.cmd.sanity_check:main
+    neutron-avs-agent = neutron.plugins.wrs.agent.avs.agent:main
+    neutron-avr-agent = neutron.plugins.wrs.agent.avr.agent:main
 neutron.core_plugins =
     ml2 = neutron.plugins.ml2.plugin:Ml2Plugin
 neutron.service_plugins =
@@ -103,6 +105,7 @@ neutron.ml2.mechanism_drivers =
     sriovnicswitch = neutron.plugins.ml2.drivers.mech_sriov.mech_driver.mech_driver:SriovNicSwitchMechanismDriver
     fake_agent = neutron.tests.unit.plugins.ml2.drivers.mech_fake_agent:FakeAgentMechanismDriver
     faulty_agent = neutron.tests.unit.plugins.ml2.drivers.mech_faulty_agent:FaultyAgentMechanismDriver
+    vswitch = neutron.plugins.wrs.drivers.mech_vswitch:VSwitchMechanismDriver
 neutron.ml2.extension_drivers =
     test = neutron.tests.unit.plugins.ml2.drivers.ext_test:TestExtensionDriver
     testdb = neutron.tests.unit.plugins.ml2.drivers.ext_test:TestDBExtensionDriver
@@ -143,6 +146,7 @@ oslo.config.opts =
     neutron.ml2.sriov.agent = neutron.opts:list_sriov_agent_opts
     neutron.ml2.xenapi = neutron.opts:list_xenapi_opts
     neutron.settings = neutron.opts:list_settings_opts
+    neutron.avs.agent = neutron.opts:list_avs_agent_opts
     nova.auth = neutron.opts:list_auth_opts
 oslo.config.opts.defaults =
     neutron = neutron.common.config:set_cors_middleware_defaults
@@ -153,6 +157,7 @@ neutron.interface_drivers =
     linuxbridge = neutron.agent.linux.interface:BridgeInterfaceDriver
     null = neutron.agent.linux.interface:NullDriver
     openvswitch = neutron.agent.linux.interface:OVSInterfaceDriver
+    vswitch = neutron.agent.vswitch.interface:VSwitchInterfaceDriver
 neutron.agent.firewall_drivers =
     noop = neutron.agent.firewall:NoopFirewallDriver
     iptables = neutron.agent.linux.iptables_firewall:IptablesFirewallDriver
@@ -161,6 +166,7 @@ neutron.agent.firewall_drivers =
 neutron.services.metering_drivers =
     noop = neutron.services.metering.drivers.noop.noop_driver:NoopMeteringDriver
     iptables = neutron.services.metering.iptables.iptables_driver:IptablesMeteringDriver
+    vswitch = neutron.plugins.wrs.drivers.firewall:VSwitchFirewallDriver
 tempest.test_plugins =
     neutron_tests = neutron.tests.tempest.plugin:NeutronTempestPlugin
 
-- 
2.7.4

